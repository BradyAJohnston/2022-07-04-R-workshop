{
  "hash": "2476ea10014aec1677e82d20f26e534b",
  "result": {
    "markdown": "---\ntitle: \"SQL databases and R\"\nauthor: \"Data Carpentry contributors\"\noutput:\n  html_document:\n    df_print: paged\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n------------\n\n> ### Learning Objectives\n>\n> * Access a database from R.\n> * Run SQL queries in R using **`RSQLite`** and **`dplyr`**.\n> * Describe the lazy behavior of dplyr on data stored in a database outside of R.\n> * Prototype queries and retrieve all final results.\n> * Create complex queries across one or multiple database tables.\n> * Create an SQLite database from existing .csv files.\n\n------------\n\n## Introduction\n\n\nSo far, we have dealt with small datasets that easily fit into your computer's\nmemory. But what about datasets that are too large for your computer to\nhandle as a whole? In this case, storing the data outside of R and organizing it\nin a database is helpful. Connecting to the database allows you to retrieve only\nthe chunks needed for the current analysis.\n\nEven better, many large datasets are already available in public or private\ndatabases. You can query them without having to download the data first.\n\nR can connect to almost any existing database type. Most common database types\nhave R packages that allow you to connect to them (e.g., **`RSQLite`**, RMySQL,\netc). Furthermore,\nthe [**`dplyr`**](https://cran.r-project.org/web/packages/dplyr/index.html) package\nyou used in the previous chapter, in conjunction with [**`dbplyr`**](https://cran.r-project.org/package=dbplyr)\nsupports connecting to the widely-used open\nsource databases [sqlite](https://sqlite.org/), [mysql](https://www.mysql.com/)\nand [postgresql](https://www.postgresql.org/), as well as\nGoogleâ€™s [bigquery](https://cloud.google.com/bigquery/), and it can also be\nextended to other database types (a [vignette](https://cran.r-project.org/web/packages/dbplyr/vignettes/new-backend.html)\nin the **`dplyr`** package explains how to do it). RStudio has created\n[a website](http://db.rstudio.com/) that provides documentation and best practices\nto work on database interfaces.\n\nInterfacing with databases using **`dplyr`** focuses on retrieving and analyzing\ndatasets by generating `SELECT` SQL statements, but it doesn't modify the\ndatabase itself. **`dplyr`** does not offer functions to `UPDATE` or `DELETE`\nentries. If you need these functionalities, you will need to use additional R\npackages (e.g., **`RSQLite`**). Here we will demonstrate how to interact with a\ndatabase using **`dplyr`**, using both the **`dplyr`**'s verb syntax and the SQL syntax.\n\n### The portal_mammals database\n\nWe will continue to explore the `surveys` data you are already familiar with\nfrom previous lessons. First, we are going to install the **`dbplyr`** package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"dbplyr\", \"RSQLite\"))\n```\n:::\n\n\nThe SQLite database is contained in a single file `portal_mammals.sqlite`\nthat you generated during\n[the SQL lesson](https://datacarpentry.org/sql-ecology-lesson/00-sql-introduction/index.html).\nIf you don't have it, you can download it from Figshare into the `data_raw` subdirectory using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir.create(\"data_raw\", showWarnings = FALSE)\ndownload.file(url = \"https://ndownloader.figshare.com/files/2292171\",\n              destfile = \"data_raw/portal_mammals.sqlite\", mode = \"wb\")\n```\n:::\n\n\n## Connecting to databases\n\nWe can point R to this database using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(dbplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> \n#> Attaching package: 'dbplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n#> The following objects are masked from 'package:dplyr':\n#> \n#>     ident, sql\n```\n:::\n\n```{.r .cell-code}\nmammals <- DBI::dbConnect(RSQLite::SQLite(), \"data_raw/portal_mammals.sqlite\")\n```\n:::\n\n\nThis command uses 2 packages that helps **`dbplyr`** and **`dplyr`** talk to the\nSQLite database. **`DBI`** is not something that you'll use directly as a user.\nIt allows R to send commands to databases irrespective of the database management\nsystem used. The **`RSQLite`** package allows R to interface with SQLite databases.\n\nThis command does not load the data into the R session (as the\n`read_csv()` function did). Instead, it merely instructs R to connect to\nthe `SQLite` database contained in the `portal_mammals.sqlite` file.\n\nUsing a similar approach, you could connect to many other database management\nsystems that are supported by R including MySQL, PostgreSQL, BigQuery, etc.\n\nLet's take a closer look at the `mammals` database we just connected to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrc_dbi(mammals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> src:  sqlite 3.38.5 [/Users/brady/git/rworkshop/2022-07-04-R-workshop/data_raw/portal_mammals.sqlite]\n#> tbls: plots, species, surveys\n```\n:::\n:::\n\n\nJust like a spreadsheet with multiple worksheets, a SQLite database can contain\nmultiple tables. In this case three of them are listed in the `tbls` row in the\noutput above:\n\n* plots\n* species\n* surveys\n\nNow that we know we can connect to the database, let's explore how to get\nthe data from its tables into R.\n\n### Querying the database with the SQL syntax\n\nTo connect to tables within a database, you can use the `tbl()` function from\n**`dplyr`**. This function can be used to send SQL queries to the database. To\ndemonstrate this functionality, let's select the columns \"year\", \"species_id\",\nand \"plot_id\" from the `surveys` table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(mammals, sql(\"SELECT year, species_id, plot_id FROM surveys\"))\n```\n:::\n\n\nWith this approach you can use any of the SQL queries we have seen in the\ndatabase lesson.\n\n### Querying the database with the dplyr syntax\n\nOne of the strengths of **`dplyr`** is that the same operation can be done using\n**`dplyr`**'s verbs instead of writing SQL. First, we select the table on which to do\nthe operations by creating the `surveys` object, and then we use the standard\n**`dplyr`** syntax as if it were a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys <- tbl(mammals, \"surveys\")\nsurveys %>%\n    select(year, species_id, plot_id)\n```\n:::\n\n\nIn this case, the `surveys` object behaves like a data frame. Several\nfunctions that can be used with data frames can also be used on tables from a\ndatabase. For instance, the `head()` function can be used to check the first 10\nrows of the table:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(surveys, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # Source:   SQL [10 x 9]\n#> # Database: sqlite 3.38.5 [/Users/brady/git/rworkshop/2022-07-04-R-workshop/data_raw/portal_mammals.sqlite]\n#>    record_id month   day  year plot_id species_id sex   hindfoot_length weight\n#>        <int> <int> <int> <int>   <int> <chr>      <chr>           <int>  <int>\n#>  1         1     7    16  1977       2 NL         M                  32     NA\n#>  2         2     7    16  1977       3 NL         M                  33     NA\n#>  3         3     7    16  1977       2 DM         F                  37     NA\n#>  4         4     7    16  1977       7 DM         M                  36     NA\n#>  5         5     7    16  1977       3 DM         M                  35     NA\n#>  6         6     7    16  1977       1 PF         M                  14     NA\n#>  7         7     7    16  1977       2 PE         F                  NA     NA\n#>  8         8     7    16  1977       1 DM         M                  37     NA\n#>  9         9     7    16  1977       1 DM         F                  34     NA\n#> 10        10     7    16  1977       6 PF         F                  20     NA\n```\n:::\n:::\n\n\nThis output of the `head` command looks just like a regular `data.frame`:\nThe table has 9 columns and the `head()` command shows us the first 10 rows.\nNote that the columns `plot_type`, `taxa`, `genus`, and `species` are missing.\nThese are now located in the tables `plots` and `species` which we will join\ntogether in a moment.\n\nHowever, some functions don't work quite as expected. For instance, let's check\nhow many rows there are in total using `nrow()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(surveys)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] NA\n```\n:::\n:::\n\n\nThat's strange - R doesn't know how many rows the `surveys` table contains - it\nreturns `NA` instead. You might have already noticed that the first line of\nthe `head()` output included `??` indicating that the number of rows wasn't\nknown.\n\nThe reason for this behavior highlights a key difference between using\n**`dplyr`** on datasets in memory (e.g. loaded into your R session via\n`read_csv()`) and those provided by a database. To understand it, we take a\ncloser look at how **`dplyr`** communicates with our SQLite database.\n\n### SQL translation\n\nRelational databases typically use a special-purpose language,\n[Structured Query Language (SQL)](https://en.wikipedia.org/wiki/SQL),\nto manage and query data.\n\nFor example, the following SQL query returns the first 10 rows from the\n`surveys` table:\n\n```sql\nSELECT *\nFROM `surveys`\nLIMIT 10\n```\n\nBehind the scenes, **`dplyr`**:\n\n1. translates your R code into SQL\n2. submits it to the database\n3. translates the database's response into an R data frame\n\nTo lift the curtain, we can use **`dplyr`**'s `show_query()` function to show which SQL\ncommands are actually sent to the database:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_query(head(surveys, n = 10))\n```\n:::\n\n\nThe output shows the actual SQL query sent to the database; it matches our\nmanually constructed `SELECT` statement above.\n\nInstead of having to formulate the SQL query ourselves - and\nhaving to mentally switch back and forth between R and SQL syntax - we can\ndelegate this translation to **`dplyr`**. (You don't even need to know SQL to interact\nwith a database via **`dplyr`**!)\n\n**`dplyr`**, in turn, doesn't do the real work of subsetting the table, either.\nInstead, it merely sends the query to the database, waits for its response and\nreturns it to us.\n\nThat way, R never gets to see the full `surveys` table - and that's why it could\nnot tell us how many rows it contains. On the bright side, this allows us to work\nwith large datasets - even too large to fit into our computer's memory.\n\n**`dplyr`** can translate many different query types into SQL allowing us to, e.g.,\n`select()` specific columns, `filter()` rows, or join tables.\n\nTo see this in action, let's compose a few queries with **`dplyr`**.\n\n## Simple database queries\n\nFirst, let's only request rows of the `surveys` table in which `weight` is less\nthan 5 and keep only the species_id, sex, and weight columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys %>%\n  filter(weight < 5) %>%\n  select(species_id, sex, weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # Source:   SQL [?? x 3]\n#> # Database: sqlite 3.38.5 [/Users/brady/git/rworkshop/2022-07-04-R-workshop/data_raw/portal_mammals.sqlite]\n#>    species_id sex   weight\n#>    <chr>      <chr>  <int>\n#>  1 PF         M          4\n#>  2 PF         F          4\n#>  3 PF         <NA>       4\n#>  4 PF         F          4\n#>  5 PF         F          4\n#>  6 RM         M          4\n#>  7 RM         F          4\n#>  8 RM         M          4\n#>  9 RM         M          4\n#> 10 RM         M          4\n#> # â€¦ with more rows\n```\n:::\n:::\n\n\nExecuting this command will return a table with 10 rows and the requested\n`species_id`, `sex` and `weight` columns. Great!\n\n... but wait, why are there only 10 rows?\n\nThe last line:\n\n```\n# ... with more rows\n```\n\nindicates that there are more results that fit our filtering criterion. Why was\nR lazy and only retrieved 10 of them?\n\n## Laziness\n\nHadley Wickham, the author of **`dplyr`**\n[explains](https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html):\n\n> When working with databases, **`dplyr`** tries to be as lazy as possible:\n>\n> * It never pulls data into R unless you explicitly ask for it.\n> * It delays doing any work until the last possible moment - it collects together\n> everything you want to do and then sends it to the database in one step.\n\nWhen you construct a **`dplyr`** query, you can connect multiple verbs into a single\npipeline. For example, we combined the `filter()` and `select()` verbs using the\n`%>%` pipe.\n\nIf we wanted to, we could add on even more steps, e.g. remove the `sex` column\nin an additional `select` call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_subset <- surveys %>%\n  filter(weight < 5) %>%\n  select(species_id, sex, weight)\n\ndata_subset %>%\n  select(-sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # Source:   SQL [?? x 2]\n#> # Database: sqlite 3.38.5 [/Users/brady/git/rworkshop/2022-07-04-R-workshop/data_raw/portal_mammals.sqlite]\n#>    species_id weight\n#>    <chr>       <int>\n#>  1 PF              4\n#>  2 PF              4\n#>  3 PF              4\n#>  4 PF              4\n#>  5 PF              4\n#>  6 RM              4\n#>  7 RM              4\n#>  8 RM              4\n#>  9 RM              4\n#> 10 RM              4\n#> # â€¦ with more rows\n```\n:::\n:::\n\n\nJust like the first `select(species_id, sex, weight)` call, the `select(-sex)`\ncommand is not executed by R. It is sent to the database instead. Only the\n_final_ result is retrieved and displayed to you.\n\nOf course, we could always add on more steps, e.g., we could filter by\n`species_id` or  minimum `weight`. That's why R doesn't retrieve the full set\nof results - instead it only retrieves the first 10 results from the database\nby default. (After all, you might want to add an additional step and get the\ndatabase to do more work...)\n\nTo instruct R to stop being lazy, e.g. to retrieve all of the query results from\nthe database, we add the `collect()` command to our pipe. It indicates that our\ndatabase query is finished: time to get the _final_ results and load them into\nthe R session.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_subset <- surveys %>%\n  filter(weight < 5) %>%\n  select(species_id, sex, weight) %>%\n  collect()\n```\n:::\n\n\nNow we have all 17 rows that match our query in a `data.frame` and can continue\nto work with them exclusively in R, without communicating with the database.\n\n## Complex database queries\n\n**`dplyr`** enables database queries across one or multiple database tables, using\nthe same single- and multiple-table verbs you encountered previously. This means\nyou can use the same commands regardless of whether you interact with a remote\ndatabase or local dataset! This is a really useful feature if you work with\nlarge datasets: you can first prototype your code on a small subset that fits\ninto memory, and when your code is ready, you can change the input dataset to\nyour full database without having to change the syntax.\n\nOn the other hand, being able to use SQL queries directly can be useful if your\ncollaborators have already put together complex queries to prepare the dataset\nthat you need for your analysis.\n\nTo illustrate how to use **`dplyr`** with these complex queries, we are going to join\nthe `plots` and `surveys` tables. The `plots` table in the database contains\ninformation about the different plots surveyed by the researchers. To access it,\nwe point the `tbl()` command to it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplots <- tbl(mammals, \"plots\")\nplots\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # Source:   table<plots> [?? x 2]\n#> # Database: sqlite 3.38.5 [/Users/brady/git/rworkshop/2022-07-04-R-workshop/data_raw/portal_mammals.sqlite]\n#>    plot_id plot_type                \n#>      <int> <chr>                    \n#>  1       1 Spectab exclosure        \n#>  2       2 Control                  \n#>  3       3 Long-term Krat Exclosure \n#>  4       4 Control                  \n#>  5       5 Rodent Exclosure         \n#>  6       6 Short-term Krat Exclosure\n#>  7       7 Rodent Exclosure         \n#>  8       8 Control                  \n#>  9       9 Spectab exclosure        \n#> 10      10 Rodent Exclosure         \n#> # â€¦ with more rows\n```\n:::\n:::\n\n\nThe `plot_id` column also features in the `surveys` table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # Source:   table<surveys> [?? x 9]\n#> # Database: sqlite 3.38.5 [/Users/brady/git/rworkshop/2022-07-04-R-workshop/data_raw/portal_mammals.sqlite]\n#>    record_id month   day  year plot_id species_id sex   hindfoot_length weight\n#>        <int> <int> <int> <int>   <int> <chr>      <chr>           <int>  <int>\n#>  1         1     7    16  1977       2 NL         M                  32     NA\n#>  2         2     7    16  1977       3 NL         M                  33     NA\n#>  3         3     7    16  1977       2 DM         F                  37     NA\n#>  4         4     7    16  1977       7 DM         M                  36     NA\n#>  5         5     7    16  1977       3 DM         M                  35     NA\n#>  6         6     7    16  1977       1 PF         M                  14     NA\n#>  7         7     7    16  1977       2 PE         F                  NA     NA\n#>  8         8     7    16  1977       1 DM         M                  37     NA\n#>  9         9     7    16  1977       1 DM         F                  34     NA\n#> 10        10     7    16  1977       6 PF         F                  20     NA\n#> # â€¦ with more rows\n```\n:::\n:::\n\n\nBecause `plot_id` is listed in both tables, we can use it to look up matching\nrecords, and join the two tables.\n\nIf we have two tables named x and y with a common column called \"ID\", we can join them using 'join' functions, two of which are described and illustrated below.\n\n1. inner_join() : This returns all rows from x where there are matching values in y, and all columns from x and y.\n\n2. left_join() : This return all rows from x, and all columns from x and y. Rows in x with no match in y will have NA values in the new columns.  \n\nIn both forms of join, if there are multiple matches between x and y, all combinations of the matches are returned. For the full list of 'join' functions, check out the [tidyverse join page.](https://dplyr.tidyverse.org/reference/mutate-joins.html)\n\nIn our example, the two tables we want to join are 'plots' and 'surveys'.\n\n![diagram illustrating inner and left joins](./img/joins.svg)\n\n\nFor example, to extract all surveys for the first plot, which has `plot_id` 1,\nwe can do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplots %>%\n  filter(plot_id == 1) %>%\n  inner_join(surveys) %>%\n  collect()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Joining, by = \"plot_id\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1,995 Ã— 10\n#>    plot_id plot_type         record_id month   day  year species_id sex  \n#>      <int> <chr>                 <int> <int> <int> <int> <chr>      <chr>\n#>  1       1 Spectab exclosure         6     7    16  1977 PF         M    \n#>  2       1 Spectab exclosure         8     7    16  1977 DM         M    \n#>  3       1 Spectab exclosure         9     7    16  1977 DM         F    \n#>  4       1 Spectab exclosure        78     8    19  1977 PF         M    \n#>  5       1 Spectab exclosure        80     8    19  1977 DS         M    \n#>  6       1 Spectab exclosure       218     9    13  1977 PF         M    \n#>  7       1 Spectab exclosure       222     9    13  1977 DS         M    \n#>  8       1 Spectab exclosure       239     9    13  1977 DS         M    \n#>  9       1 Spectab exclosure       263    10    16  1977 DM         M    \n#> 10       1 Spectab exclosure       270    10    16  1977 DM         F    \n#> # â€¦ with 1,985 more rows, and 2 more variables: hindfoot_length <int>,\n#> #   weight <int>\n```\n:::\n:::\n\n\n\n\n**Important Note:** Without the `collect()` statement, only the first 10\nmatching rows are returned. By adding `collect()`, the full set of 1,985 is\nretrieved.\n\n> ### Challenge\n>\n> Write a query that returns the number of rodents observed in each plot in\n> each year.\n>\n> Hint: Connect to the species table and write a query that joins the species\n> and survey tables together to exclude all non-rodents.\n> The query should return counts of rodents by year.\n>\n> Optional: Write a query in SQL that will produce the same result. You can join\n> multiple tables together using the following syntax where foreign key refers\n> to your unique id (e.g., `species_id`):\n>\n> ```sql\n> SELECT table.col, table.col\n> FROM table1 JOIN table2\n> ON table1.key = table2.key\n> JOIN table3 ON table2.key = table3.key\n> ```\n>\n> ::: {.cell answer='true'}\n> <div class=\"accordion\">\n> <h3 class=\"toc-ignore\">Answer</h3>\n> <div style=\"background: #fff;\">\n> \n> ```{.r .cell-code}\n> ## with dplyr syntax\n> species <- tbl(mammals, \"species\")\n> \n> left_join(surveys, species) %>%\n>   filter(taxa == \"Rodent\") %>%\n>   group_by(taxa, year, plot_id) %>%\n>   tally() %>%\n>   collect()\n> ```\n> \n> ::: {.cell-output .cell-output-stderr}\n> ```\n> #> Joining, by = \"species_id\"\n> ```\n> :::\n> \n> ```{.r .cell-code}\n> ## with SQL syntax\n> query <- paste(\"\n> SELECT a.year, b.taxa,count(*) as count\n> FROM surveys a\n> JOIN species b\n> ON a.species_id = b.species_id\n> AND b.taxa = 'Rodent'\n> GROUP BY b.taxa, a.year, a.plot_id\",\n> sep = \"\" )\n> \n> tbl(mammals, sql(query))\n> ```\n> \n> </div>\n> </div>\n> :::\n\n\n\n::: {.cell}\n\n:::\n\n\n> ### Challenge\n>\n>  Write a query that returns the total number of rodents in each genus caught\n>  in the different plot types.\n>\n>  Hint: Write a query that joins the species, plot, and survey tables together.\n>  The query should return counts of genus by plot type.\n>\n> ::: {.cell answer='true'}\n> <div class=\"accordion\">\n> <h3 class=\"toc-ignore\">Answer</h3>\n> <div style=\"background: #fff;\">\n> \n> ```{.r .cell-code}\n> species <- tbl(mammals, \"species\")\n> genus_counts <- left_join(surveys, plots) %>%\n>   left_join(species) %>%\n>   filter(taxa == \"Rodent\") %>%\n>   group_by(plot_type, genus) %>%\n>   tally() %>%\n>   collect()\n> ```\n> \n> </div>\n> </div>\n> :::\n\n\n\n\n::: {.cell}\n\n:::\n\n\nThis is useful if we are interested in estimating the number of individuals\nbelonging to each genus found in each plot type. But what if we were interested\nin the number of genera found in each plot type? Using `tally()` gives the\nnumber of individuals, instead we need to use `n_distinct()` to count the\nnumber of unique values found in a column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- tbl(mammals, \"species\")\nunique_genera <- left_join(surveys, plots) %>%\n    left_join(species) %>%\n    group_by(plot_type) %>%\n    summarize(\n        n_genera = n_distinct(genus)\n    ) %>%\n    collect()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Joining, by = \"plot_id\"\n#> Joining, by = \"species_id\"\n```\n:::\n:::\n\n\n`n_distinct`, like the other **`dplyr`** functions we have used in this lesson, works\nnot only on database connections but also on regular data frames.\n\n\n## Creating a new SQLite database\n\nSo far, we have used a previously prepared SQLite database. But we can also\nuse R to create a new database, e.g. from existing `csv` files.  Let's recreate\nthe mammals database that we've been working with, in R. First let's download and read in the\n`csv` files.  We'll import **`tidyverse`** to gain access to the `read_csv()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload.file(\"https://ndownloader.figshare.com/files/3299483\",\n              \"data_raw/species.csv\")\ndownload.file(\"https://ndownloader.figshare.com/files/10717177\",\n              \"data_raw/surveys.csv\")\ndownload.file(\"https://ndownloader.figshare.com/files/3299474\",\n              \"data_raw/plots.csv\")\nlibrary(tidyverse)\nspecies <- read_csv(\"data_raw/species.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Rows: 54 Columns: 4\n#> â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n#> Delimiter: \",\"\n#> chr (4): species_id, genus, species, taxa\n#> \n#> â„¹ Use `spec()` to retrieve the full column specification for this data.\n#> â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nsurveys <- read_csv(\"data_raw/surveys.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Rows: 35549 Columns: 9\n#> â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n#> Delimiter: \",\"\n#> chr (2): species_id, sex\n#> dbl (7): record_id, month, day, year, plot_id, hindfoot_length, weight\n#> \n#> â„¹ Use `spec()` to retrieve the full column specification for this data.\n#> â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nplots <- read_csv(\"data_raw/plots.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Rows: 24 Columns: 2\n#> â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n#> Delimiter: \",\"\n#> chr (1): plot_type\n#> dbl (1): plot_id\n#> \n#> â„¹ Use `spec()` to retrieve the full column specification for this data.\n#> â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nAlso, you can create new SQLite database with **`dplyr`** by adding an argument to the same\ncommand we used above to open an existing `.sqlite` file. The `create = TRUE`\nargument instructs R to create a new, empty database instead.\n\n**Caution:** When `create = TRUE` is added, any existing database at the same\nlocation is overwritten _without warning_.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_db_file <- \"data/portal-database-output.sqlite\"\nmy_db <- src_sqlite(my_db_file, create = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: `src_sqlite()` was deprecated in dplyr 1.0.0.\n#> Please use `tbl()` directly with a database connection\n#> This warning is displayed once every 8 hours.\n#> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n```\n:::\n:::\n\n\nCurrently, our new database is empty, it doesn't contain any tables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_db\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> src:  sqlite 3.38.5 [/Users/brady/git/rworkshop/2022-07-04-R-workshop/data/portal-database-output.sqlite]\n#> tbls:\n```\n:::\n:::\n\n\nTo add tables, we copy the existing data.frames into the database one by one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncopy_to(my_db, surveys)\ncopy_to(my_db, plots)\nmy_db\n```\n:::\n\n\nIf you check the location of our database you'll see that data is automatically\nbeing written to disk. R and **`dplyr`** not only provide ways to query\nexisting databases, they also provide functionality to create your own databases\nfrom flat files!\n\n> ### Challenge\n>\n> Add the remaining species table to the `my_db` database and run some of your\n> queries from earlier in the lesson to verify that you have\n> faithfully recreated the mammals database.\n\n\n\n::: {.cell}\n\n:::\n\n\n**Note:** In this example, we first loaded all of the data into the R session by\nreading the three `csv` files. Because all the data has to flow through R,\nthis is not suitable for very large datasets.\n\n**Note:** Finally, to close the connection to the mammals database you may use\n`DBI::dbDisconnect(mammals)`; this discards all pending work and frees resources,\ne.g. memory.\n\n\n\n\n\n<p style=\"text-align: right; font-size: small;\">Page built on: ðŸ“† 2022-06-28 â€’ ðŸ•¢ 17:22:11</p>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}