[
  {
    "objectID": "04-visualization-ggplot2.html",
    "href": "04-visualization-ggplot2.html",
    "title": "Data visualization with ggplot2",
    "section": "",
    "text": "We start by loading the required packages. ggplot2 is included in the tidyverse package.\nIf not still in the workspace, load the data we saved in the previous lesson."
  },
  {
    "objectID": "04-visualization-ggplot2.html#plotting-with-ggplot2",
    "href": "04-visualization-ggplot2.html#plotting-with-ggplot2",
    "title": "Data visualization with ggplot2",
    "section": "Plotting with ggplot2\n",
    "text": "Plotting with ggplot2\n\nggplot2 is a plotting package that provides helpful commands to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.\nggplot2 refers to the name of the package itself. When using the package we use the function ggplot() to generate the plots, and so references to using the function will be referred to as ggplot() and the package as a whole as ggplot2\nggplot2 plots work best with data in the ‘long’ format, i.e., a column for every variable, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2\nggplot graphics are built layer by layer by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\nggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()\n\nuse the ggplot() function and bind the plot to a specific data frame using the data argument\n\n\nggplot(data = surveys_complete)\n\n\ndefine an aesthetic mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g., as x/y positions or characteristics such as size, shape, color, etc.\n\n\nggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length))\n\n\n\nadd ‘geoms’ – graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use some common ones today, including:\n\n\ngeom_point() for scatter plots, dot plots, etc.\n\ngeom_boxplot() for, well, boxplots!\n\ngeom_line() for trend lines, time series, etc.\n\n\n\nTo add a geom to the plot use + operator. Because we have two continuous variables, let’s use geom_point() first:\n\nggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +\n  geom_point()\n\n\n\n\nThe + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot “templates” and conveniently explore different types of plots, so the above plot can also be generated with code like this:\n\n# Assign plot to a variable\nsurveys_plot <- ggplot(data = surveys_complete,\n                       mapping = aes(x = weight, y = hindfoot_length))\n\n# Draw the plot\nsurveys_plot +\n    geom_point()\n\n\n\n\nNotes\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are universal plot settings). This includes the x- and y-axis you set up in aes().\nYou can also specify aesthetics for a given geom independently of the aesthetics defined globally in the ggplot() function.\nThe + sign used to add layers must be placed at the end of each line containing a layer. If, instead, the + sign is added in the line before the other layer, ggplot2 will not add the new layer and will return an error message.\nYou may notice that we sometimes reference ‘ggplot2’ and sometimes ‘ggplot’. To clarify, ‘ggplot2’ is the name of the most recent version of the package. However, any time we call the function itself, it’s just called ‘ggplot’.\nThe previous version of the ggplot2 package, called ggplot, which also contained the ggplot() function is now unsupported and has been removed from CRAN in order to reduce accidental installations and further confusion.\n\n\n# This is the correct syntax for adding layers\nsurveys_plot +\n  geom_point()\n\n# This will not add the new layer and will return an error message\nsurveys_plot\n  + geom_point()\n\n\n\n\n\n\n\nChallenge (optional)\n\n\n\nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the surveys_complete data set, overplotting of points can be a limitation of scatter plots. One strategy for handling such settings is to use hexagonal binning of observations. The plot space is tessellated into hexagons. Each hexagon is assigned a color based on the number of observations that fall within its boundaries. To use hexagonal binning with ggplot2, first install the R package hexbin from CRAN:\n\ninstall.packages(\"hexbin\")\nlibrary(hexbin)\n\nThen use the geom_hex() function:\n\nsurveys_plot +\n geom_hex()\n\n\nWhat are the relative strengths and weaknesses of a hexagonal bin plot compared to a scatter plot? Examine the above scatter plot and compare it with the hexagonal bin plot that you created."
  },
  {
    "objectID": "04-visualization-ggplot2.html#building-your-plots-iteratively",
    "href": "04-visualization-ggplot2.html#building-your-plots-iteratively",
    "title": "Data visualization with ggplot2",
    "section": "Building your plots iteratively",
    "text": "Building your plots iteratively\nBuilding plots with ggplot2 is typically an iterative process. We start by defining the dataset we’ll use, lay out the axes, and choose a geom:\n\nggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +\n    geom_point()\n\n\n\n\nThen, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1)\n\n\n\n\nWe can also add colors for all the points:\n\nggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1, color = \"blue\")\n\n\n\n\nOr to color each species in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with species_id:\n\nggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1, aes(color = species_id))\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a scatter plot of weight over species_id with the plot types showing in different colors. Is this a good way to show this type of data?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = surveys_complete,\n       mapping = aes(x = species_id, y = weight)) +\n   geom_point(aes(color = plot_type))"
  },
  {
    "objectID": "04-visualization-ggplot2.html#boxplot",
    "href": "04-visualization-ggplot2.html#boxplot",
    "title": "Data visualization with ggplot2",
    "section": "Boxplot",
    "text": "Boxplot\nWe can use boxplots to visualize the distribution of weight within each species:\n\nggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +\n    geom_boxplot()\n\n\n\n\nBy adding points to the boxplot, we can have a better idea of the number of measurements and of their distribution:\n\nggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +\n    geom_boxplot(alpha = 0) +\n    geom_jitter(alpha = 0.3, color = \"tomato\")\n\n\n\n\nNotice how the boxplot layer is behind the jitter layer? What do you need to change in the code to put the boxplot in front of the points such that it’s not hidden?\n\n\n\n\n\n\nChallenges\n\n\n\nBoxplots are useful summaries, but hide the shape of the distribution. For example, if there is a bimodal distribution, it would not be observed with a boxplot. An alternative to the boxplot is the violin plot (sometimes known as a beanplot), where the shape (of the density of points) is drawn.\n\nReplace the box plot with a violin plot; see geom_violin().\n\nIn many types of data, it is important to consider the scale of the observations. For example, it may be worth changing the scale of the axis to better distribute the observations in the space of the plot. Changing the scale of the axes is done similarly to adding/modifying other components (i.e., by incrementally adding commands). Try making these modifications:\n\nRepresent weight on the log10 scale; see scale_y_log10().\n\nSo far, we’ve looked at the distribution of weight within species. Try making a new plot to explore the distribution of another variable within each species.\n\nCreate boxplot for hindfoot_length. Overlay the boxplot layer on a jitter layer to show actual measurements.\nAdd color to the data points on your boxplot according to the plot from which the sample was taken (plot_id). Hint: Check the class for plot_id. Consider changing the class of plot_id from integer to factor. Why does this change how R makes the graph?"
  },
  {
    "objectID": "04-visualization-ggplot2.html#plotting-time-series-data",
    "href": "04-visualization-ggplot2.html#plotting-time-series-data",
    "title": "Data visualization with ggplot2",
    "section": "Plotting time series data",
    "text": "Plotting time series data\nLet’s calculate number of counts per year for each genus. First we need to group the data and count records within each group:\n\nyearly_counts <- surveys_complete %>%\n  count(year, genus)\n\nTimelapse data can be visualized as a line plot with years on the x-axis and counts on the y-axis:\n\nggplot(data = yearly_counts, aes(x = year, y = n)) +\n     geom_line()\n\n\n\n\nUnfortunately, this does not work because we plotted data for all the genera together. We need to tell ggplot to draw a line for each genus by modifying the aesthetic function to include group = genus:\n\nggplot(data = yearly_counts, aes(x = year, y = n, group = genus)) +\n    geom_line()\n\n\n\n\nWe will be able to distinguish genera in the plot if we add colors (using color also automatically groups the data):\n\nggplot(data = yearly_counts, aes(x = year, y = n, color = genus)) +\n    geom_line()"
  },
  {
    "objectID": "04-visualization-ggplot2.html#integrating-the-pipe-operator-with-ggplot2",
    "href": "04-visualization-ggplot2.html#integrating-the-pipe-operator-with-ggplot2",
    "title": "Data visualization with ggplot2",
    "section": "Integrating the pipe operator with ggplot2",
    "text": "Integrating the pipe operator with ggplot2\nIn the previous lesson, we saw how to use the pipe operator %>% to use different functions in a sequence and create a coherent workflow. We can also use the pipe operator to pass the data argument to the ggplot() function. The hard part is to remember that to build your ggplot, you need to use + and not %>%.\n\nyearly_counts %>%\n    ggplot(mapping = aes(x = year, y = n, color = genus)) +\n    geom_line()\n\n\n\n\nThe pipe operator can also be used to link data manipulation with consequent data visualization.\n\nyearly_counts_graph <- surveys_complete %>%\n    count(year, genus) %>%\n    ggplot(mapping = aes(x = year, y = n, color = genus)) +\n    geom_line()\n\nyearly_counts_graph"
  },
  {
    "objectID": "04-visualization-ggplot2.html#faceting",
    "href": "04-visualization-ggplot2.html#faceting",
    "title": "Data visualization with ggplot2",
    "section": "Faceting",
    "text": "Faceting\nggplot has a special technique called faceting that allows the user to split one plot into multiple plots based on a factor included in the dataset. We will use it to make a time series plot for each genus:\n\nggplot(data = yearly_counts, aes(x = year, y = n)) +\n    geom_line() +\n    facet_wrap(facets = vars(genus))\n\n\n\n\nNow we would like to split the line in each plot by the sex of each individual measured. To do that we need to make counts in the data frame grouped by year, genus, and sex:\n\n yearly_sex_counts <- surveys_complete %>%\n                      count(year, genus, sex)\n\nWe can now make the faceted plot by splitting further by sex using color (within a single plot):\n\nggplot(data = yearly_sex_counts, mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_wrap(facets =  vars(genus))\n\n\n\n\nWe can also facet both by sex and genus:\n\nggplot(data = yearly_sex_counts,\n       mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_grid(rows = vars(sex), cols =  vars(genus))\n\n\n\n\nYou can also organise the panels only by rows (or only by columns):\n\n# One column, facet by rows\nggplot(data = yearly_sex_counts,\n       mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_grid(rows = vars(genus))\n\n\n\n\n\n# One row, facet by column\nggplot(data = yearly_sex_counts,\n       mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_grid(cols = vars(genus))\n\n\n\n\nNote: ggplot2 before version 3.0.0 used formulas to specify how plots are faceted. If you encounter facet_grid/wrap(...) code containing ~, please read https://ggplot2.tidyverse.org/news/#tidy-evaluation."
  },
  {
    "objectID": "04-visualization-ggplot2.html#ggplot2-themes",
    "href": "04-visualization-ggplot2.html#ggplot2-themes",
    "title": "Data visualization with ggplot2",
    "section": "\nggplot2 themes",
    "text": "ggplot2 themes\nUsually plots with white background look more readable when printed. Every single component of a ggplot graph can be customized using the generic theme() function, as we will see below. However, there are pre-loaded themes available that change the overall appearance of the graph without much effort.\nFor example, we can change our previous graph to have a simpler white background using the theme_bw() function:\n\n ggplot(data = yearly_sex_counts,\n        mapping = aes(x = year, y = n, color = sex)) +\n     geom_line() +\n     facet_wrap(vars(genus)) +\n     theme_bw()\n\n\n\n\nIn addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme.\nThe ggthemes package provides a wide variety of options.\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a plot that depicts how the average weight of each species changes through the years.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nyearly_weight <- surveys_complete %>%\n                group_by(year, species_id) %>%\n                 summarize(avg_weight = mean(weight))\n\n#> `summarise()` has grouped output by 'year'. You can override using the\n#> `.groups` argument.\n\nggplot(data = yearly_weight, mapping = aes(x=year, y=avg_weight)) +\n   geom_line() +\n   facet_wrap(vars(species_id)) +\n   theme_bw()"
  },
  {
    "objectID": "04-visualization-ggplot2.html#customization",
    "href": "04-visualization-ggplot2.html#customization",
    "title": "Data visualization with ggplot2",
    "section": "Customization",
    "text": "Customization\nTake a look at the ggplot2 cheat sheet, and think of ways you could improve the plot.\nNow, let’s change names of axes to something more informative than ‘year’ and ‘n’ and add a title to the figure:\n\nggplot(data = yearly_sex_counts, aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n         x = \"Year of observation\",\n         y = \"Number of individuals\") +\n    theme_bw()\n\n\n\n\nThe axes have more informative names, but their readability can be improved by increasing the font size. This can be done with the generic theme() function:\n\nggplot(data = yearly_sex_counts, mapping = aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n        x = \"Year of observation\",\n        y = \"Number of individuals\") +\n    theme_bw() +\n    theme(text=element_text(size = 16))\n\n\n\n\nNote that it is also possible to change the fonts of your plots. If you are on Windows, you may have to install the extrafont package, and follow the instructions included in the README for this package.\nAfter our manipulations, you may notice that the values on the x-axis are still not properly readable. Let’s change the orientation of the labels and adjust them vertically and horizontally so they don’t overlap. You can use a 90 degree angle, or experiment to find the appropriate angle for diagonally oriented labels. We can also modify the facet label text (strip.text) to italicize the genus names:\n\nggplot(data = yearly_sex_counts, mapping = aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n        x = \"Year of observation\",\n        y = \"Number of individuals\") +\n    theme_bw() +\n    theme(axis.text.x = element_text(colour = \"grey20\", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),\n                        axis.text.y = element_text(colour = \"grey20\", size = 12),\n                        strip.text = element_text(face = \"italic\"),\n                        text = element_text(size = 16))\n\n\n\n\nIf you like the changes you created better than the default theme, you can save them as an object to be able to easily apply them to other plots you may create:\n\ngrey_theme <- theme(axis.text.x = element_text(colour=\"grey20\", size = 12,\n                                               angle = 90, hjust = 0.5,\n                                               vjust = 0.5),\n                    axis.text.y = element_text(colour = \"grey20\", size = 12),\n                    text=element_text(size = 16))\n\nggplot(surveys_complete, aes(x = species_id, y = hindfoot_length)) +\n    geom_boxplot() +\n    grey_theme\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWith all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio ggplot2 cheat sheet for inspiration.\nHere are some ideas:\n\nSee if you can change the thickness of the lines.\nCan you find a way to change the name of the legend? What about its labels?\nTry using a different color palette (see https://www.cookbook-r.com/Graphs/Colors_(ggplot2)/)."
  },
  {
    "objectID": "04-visualization-ggplot2.html#arranging-plots",
    "href": "04-visualization-ggplot2.html#arranging-plots",
    "title": "Data visualization with ggplot2",
    "section": "Arranging plots",
    "text": "Arranging plots\nFaceting is a great tool for splitting one plot into multiple plots, but sometimes you may want to produce a single figure that contains multiple plots using different variables or even different data frames. The patchwork package allows us to combine separate ggplots into a single figure while keeping everything aligned properly. Like most R packages, we can install patchwork from CRAN, the R package repository:\n\ninstall.packages(\"patchwork\")\n\nAfter you have loaded the patchwork package you can use + to place plots next to each other, / to arrange them vertically, and plot_layout() to determine how much space each plot uses:\n\nlibrary(patchwork)\n\nplot_weight <- ggplot(data = surveys_complete, aes(x = species_id, y = weight)) +\n  geom_boxplot() +\n  labs(x = \"Species\", y = expression(log[10](Weight))) +\n  scale_y_log10()\n\nplot_count <- ggplot(data = yearly_counts, aes(x = year, y = n, color = genus)) +\n  geom_line() +\n  labs(x = \"Year\", y = \"Abundance\")\n\npatch <- plot_weight / plot_count + plot_layout(heights = c(3, 2))\npatch\n\n\n\n\nYou can also use parentheses () to create more complex layouts. There are many useful examples on the patchwork website\nAdding Tags\nPatchwork can also help you add relevant sub-panel tags.\n\npatch + plot_annotation(tag_levels = \"A\", tag_suffix = \")\")\n\n\n\npatch + plot_annotation(tag_levels = 1, tag_suffix = \")\", tag_prefix = \"(\")"
  },
  {
    "objectID": "04-visualization-ggplot2.html#exporting-plots",
    "href": "04-visualization-ggplot2.html#exporting-plots",
    "title": "Data visualization with ggplot2",
    "section": "Exporting plots",
    "text": "Exporting plots\nAfter creating your plot, you can save it to a file in your favorite format. The Export tab in the Plot pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters. The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes.\nInstead, use the ggsave() function, which allows you to easily change the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi):\n\nmy_plot <- ggplot(data = yearly_sex_counts,\n                  aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n        x = \"Year of observation\",\n        y = \"Number of individuals\") +\n    theme_bw() +\n    theme(axis.text.x = element_text(colour = \"grey20\", size = 12, angle = 90,\n                                     hjust = 0.5, vjust = 0.5),\n          axis.text.y = element_text(colour = \"grey20\", size = 12),\n          text = element_text(size = 16))\n\nggsave(\"name_of_file.png\", my_plot, width = 15, height = 10)\n\n## This also works for plots combined with patchwork\nplot_combined <- plot_weight / plot_count + plot_layout(heights = c(3, 2))\nggsave(\"plot_combined.png\", plot_combined, width = 10, dpi = 300)\n\nNote: The parameters width and height also determine the font size in the saved plot.\n\n\n\n\nPage built on: 📆 2022-06-30 ‒ 🕢 15:52:35"
  },
  {
    "objectID": "05_ggplot2_extensions.html",
    "href": "05_ggplot2_extensions.html",
    "title": "ggplot2 Extensions",
    "section": "",
    "text": "The framework introduced by the ggplot2 package allows for extremely powerful and intricate plotting to be accomplished. ggplot2 also allows for extensions to be built, from a range of authors working in a range of scientific and data-driven fields."
  },
  {
    "objectID": "05_ggplot2_extensions.html#animations",
    "href": "05_ggplot2_extensions.html#animations",
    "title": "ggplot2 Extensions",
    "section": "Animations",
    "text": "Animations\nAnimations enabled through the {gganimate} package allow for animations to be create through the use of ggplot, without any additional.\n\n# install.packages(\"gganimate\")\nlibrary(gapminder)\nlibrary(gganimate)\n\nggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +\n  geom_point(alpha = 0.7, show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10() +\n  facet_wrap(~continent) +\n  # Here comes the gganimate specific bits\n  labs(title = 'Year: {frame_time}', x = 'GDP per capita', y = 'life expectancy') +\n  transition_time(year) +\n  ease_aes('linear')"
  },
  {
    "objectID": "05_ggplot2_extensions.html#plotting-brains",
    "href": "05_ggplot2_extensions.html#plotting-brains",
    "title": "ggplot2 Extensions",
    "section": "Plotting Brains",
    "text": "Plotting Brains\nMany domain-specific packages exist, such as {ggseg} for plotting brain segmentations."
  },
  {
    "objectID": "05_ggplot2_extensions.html#publication-ready-plots",
    "href": "05_ggplot2_extensions.html#publication-ready-plots",
    "title": "ggplot2 Extensions",
    "section": "Publication-Ready Plots",
    "text": "Publication-Ready Plots\n{ggpubr} is all about quickly getting to publication-ready plots with less hassle, with geom_* functions for adding significance values and other statistical components to your plots.\n\n# install.packages('ggpubr')\nlibrary(ggpubr)\n# Load data\ndata(\"ToothGrowth\")\ndf <- ToothGrowth\nhead(df, 4)\n\n   len supp dose\n1  4.2   VC  0.5\n2 11.5   VC  0.5\n3  7.3   VC  0.5\n4  5.8   VC  0.5\n\n# Box plots with jittered points\n# :::::::::::::::::::::::::::::::::::::::::::::::::::\n# Change outline colors by groups: dose\n# Use custom color palette\n# Add jitter points and change the shape by groups\n p <- ggboxplot(df, x = \"dose\", y = \"len\",\n                color = \"dose\", palette =c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n                add = \"jitter\", shape = \"dose\")\n p\n\n\n\n# Add p-values comparing groups\n# Specify the comparisons you want\nmy_comparisons <- list( c(\"0.5\", \"1\"), c(\"1\", \"2\"), c(\"0.5\", \"2\") )\np + stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value\n  stat_compare_means(label.y = 50)                   # Add global p-value"
  },
  {
    "objectID": "05_ggplot2_extensions.html#other-packages",
    "href": "05_ggplot2_extensions.html#other-packages",
    "title": "ggplot2 Extensions",
    "section": "Other Packages",
    "text": "Other Packages\nThese packages and more can be found on the official ggplot2 extension website."
  },
  {
    "objectID": "rmarkdown.html",
    "href": "rmarkdown.html",
    "title": "R Markdown",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nCreate a .Rmd document containing R code, text, and plots\nCreate a YAML header to control output\nUnderstand basic syntax of (R)Markdown\nCustomise code chunks to control formatting\nUse code chunks and in-line code to create dynamic, reproducible documents"
  },
  {
    "objectID": "rmarkdown.html#r-markdown",
    "href": "rmarkdown.html#r-markdown",
    "title": "R Markdown",
    "section": "R Markdown",
    "text": "R Markdown\nR Markdown is a flexible type of document that allows you to seamlessly combine executable R code, and its output, with text in a single document. These documents can be readily converted to multiple static and dynamic output formats, including PDF (.pdf), Word (.docx), and HTML (.html).\nThe benefit of a well-prepared R Markdown document is full reproducibility. This also means that, if you notice a data transcription error, or you are able to add more data to your analysis, you will be able to recompile the report without making any changes in the actual document.\nThe rmarkdown package comes pre-installed with RStudio, so no action is necessary."
  },
  {
    "objectID": "rmarkdown.html#creating-an-r-markdown-file",
    "href": "rmarkdown.html#creating-an-r-markdown-file",
    "title": "R Markdown",
    "section": "Creating an R Markdown file",
    "text": "Creating an R Markdown file\nTo create a new R Markdown document in RStudio, click File -> New File -> R Markdown:\n\n\nScreenshot of the New R Markdown file dialogue box in RStudio\n\n\nThen click on ‘Create Empty Document’. Normally you could enter the title of your document, your name (Author), and select the type of output, but we will be learning how to start from a blank document."
  },
  {
    "objectID": "rmarkdown.html#basic-components-of-r-markdown",
    "href": "rmarkdown.html#basic-components-of-r-markdown",
    "title": "R Markdown",
    "section": "Basic components of R Markdown",
    "text": "Basic components of R Markdown\nTo control the output, a YAML (YAML Ain’t Markup Language) header is needed:\n---\ntitle: \"My Awesome Report\"\nauthor: \"Emmet Brickowski\"\ndate: \"\"\noutput: html_document\n---\nThe header is defined by the three hyphens at the beginning (---) and the three hyphens at the end (---).\nIn the YAML, the only required field is the output:, which specifies the type of output you want. This can be an html_document, a pdf_document, or a word_document. We will start with an HTML doument and discuss the other options later.\nThe rest of the fields can be deleted, if you don’t need them. After the header, to begin the body of the document, you start typing after the end of the YAML header (i.e. after the second ---)."
  },
  {
    "objectID": "rmarkdown.html#markdown-syntax",
    "href": "rmarkdown.html#markdown-syntax",
    "title": "R Markdown",
    "section": "Markdown syntax",
    "text": "Markdown syntax\nMarkdown is a popular markup language that allows you to add formatting elements to text, such as bold, italics, and code. The formatting will not be immediately visible in a markdown (.md) document, like you would see in a Word document. Rather, you add Markdown syntax to the text, which can then be converted to various other files that can translate the Markdown syntax. Markdown is useful because it is lightweight, flexible, and platform independent.\nSome platforms provide a real time preview of the formatting, like RStudio’s visual markdown editor (available from version 1.4).\nFirst, let’s create a heading! A # in front of text indicates to Markdown that this text is a heading. Adding more #s make the heading smaller, i.e. one # is a first level heading, two ##s is a second level heading, etc. upto the 6th level heading.\n# Title\n## Section\n### Sub-section\n#### Sub-sub section\n##### Sub-sub-sub section\n###### Sub-sub-sub-sub section\n(only use a level if the one above is also in use)\nSince we have already defined our title in the YAML header, we will use a section heading to create an Introduction section.\n## Introduction\nYou can make things bold by surrounding the word with double asterisks, **bold**, or double underscores, __bold__; and italicize using single asterisks, *italics*, or single underscores, _italics_.\nYou can also combine bold and italics to write something really important with triple-asterisks, ***really***, or underscores, ___really___; and, if you’re feeling bold (pun intended), you can also use a combination of asterisks and underscores, **_really_**, **_really_**.\nTo create code-type font, surround the word with backticks, `code-type`.\nNow that we’ve learned a couple of things, it might be useful to implement them:\n## Introduction\n\nThis report uses the **tidyverse** package along with the *SAFI* dataset, \nwhich has columns that include:\nThen we can create a list for the variables using -, +, or * keys.\n## Introduction\n\nThis report uses the **tidyverse** package along with the *SAFI* dataset, \nwhich has columns that include:\n\n- village\n- interview_date\n- no_members\n- years_liv\n- respondent_wall_type\n- rooms\nYou can also create an ordered list using numbers:\n1. village\n2. interview_date\n3. no_members\n4. years_liv\n5. respondent_wall_type\n6. rooms\nAnd nested items by tab-indenting:\n- village\n  + Name of village\n- interview_date\n  + Date of interview\n- no_members\n  + How many family members lived in a house\n- years_liv\n  + How many years respondent has lived in village or neighbouring village\n- respondent_wall_type\n  + Type of wall of house\n- rooms\n  + Number of rooms in house\nFor more Markdown syntax see the following reference guide.\nNow we can render the document into HTML by clicking the Knit button in the top of the Source pane (top left), or use the keyboard shortcut Ctrl+Shift+K on Windows and Linux, and Cmd+Shift+K on Mac. If you haven’t saved the document yet, you will be prompted to do so when you Knit for the first time.\n\n\nThe ‘knitting’ process: First, R Markdown is converted to Markdown, which is then converted (via pandoc) to .html, .pdf, .docx, etc."
  },
  {
    "objectID": "rmarkdown.html#writing-an-r-markdown-report",
    "href": "rmarkdown.html#writing-an-r-markdown-report",
    "title": "R Markdown",
    "section": "Writing an R Markdown report",
    "text": "Writing an R Markdown report\nNow we will add some R code from our previous data wrangling and visualisation, which means we need to make sure tidyverse is loaded. It is not enough to load tidyverse from the console, we will need to load it within our R Markdown document. The same applies to our data. To load these, we will need to create a ‘code chunk’ at the top of our document (below the YAML header).\nA code chunk can be inserted by clicking Code > Insert Chunk, or by using the keyboard shortcuts Ctrl+Alt+I on Windows and Linux, and Cmd+Option+I on Mac.\nThe syntax of a code chunk is:\n```{r chunk-name}\nHere is where you place the R code that you want to run.\n```\n\nAn R Markdown document knows that this text is not part of the report from the &#96;&#96;&#96 that begins and ends the chunk. It also knows that the code inside of the chunk is R code from the r inside of the curly braces ({}). After the r you can add a name for the code chunk . Naming a chunk is optional, but recommended. Each chunk name must be unique, and only contain alphanumeric characters and -.\n\n\n\nTo load tidyverse and our SAFI_clean.csv file, we will insert a chunk and call it ‘setup’. Since we don’t want this code or the output to show in our knitted HTML document, we add an include = FALSE option after the code chunk name ({r setup, include = FALSE}).\n```{r setup, include = FALSE}\nlibrary(tidyverse)\nlibrary(here)\ninterviews \n\nImportant Note!\nThe file paths you give in a .Rmd document, e.g. to load a .csv file, are relative to the .Rmd document, not the project root.\nAs suggested in the Starting with Data episode, we highly recommend the use of the here() function to keep the file paths consistent within your project. {: .callout}"
  },
  {
    "objectID": "rmarkdown.html#insert-table",
    "href": "rmarkdown.html#insert-table",
    "title": "R Markdown",
    "section": "Insert table",
    "text": "Insert table\nNext, we will re-create a table from the Data Wrangling episode which shows the average household size grouped by village and memb_assoc. We can do this by creating a new code chunk and calling it ‘interview-tbl’. Or, you can come up with something more creative (just remember to stick to the naming rules).\nIt isn’t necessary to Knit your document every time you want to see the output. Instead you can run the code chunk with the green triangle in the top right corner of the the chunk, or with the keyboard shortcuts: Ctrl+Alt+C on Windows and Linux, or Cmd+Option+C on Mac.\nTo make sure the table is formatted nicely in our output document, we will need to use the kable() function from the knitr package. The kable() function takes the output of your R code and knits it into a nice looking HTML table. You can also specify different aspects of the table, e.g. the column names, a caption, etc.\nRun the code chunk to make sure you get the desired output.\n\ninterviews %>%\n    filter(!is.na(memb_assoc)) %>%\n    group_by(village, memb_assoc) %>%\n    summarize(mean_no_membrs = mean(no_membrs)) %>%\n  knitr::kable(caption = \"We can also add a caption.\", \n               col.names = c(\"Village\", \"Member Association\", \n                             \"Mean Number of Members\"))"
  },
  {
    "objectID": "rmarkdown.html#customising-chunk-output",
    "href": "rmarkdown.html#customising-chunk-output",
    "title": "R Markdown",
    "section": "Customising chunk output",
    "text": "Customising chunk output\nWe mentioned using include = FALSE in a code chunk to prevent the code and output from printing in the knitted document. There are additional options available to customise how the code-chunks are presented in the output document. The options are entered in the code chunk after chunk-nameand separated by commas, e.g. {r chunk-name, eval = FALSE, echo = TRUE}.\n\n\n\n\n\n\n\nOption\nOptions\nOutput\n\n\n\neval\n\nTRUE or FALSE\n\nWhether or not the code within the code chunk should be run.\n\n\necho\n\nTRUE or FALSE\n\nChoose if you want to show your code chunk in the output document. echo = TRUE will show the code chunk.\n\n\ninclude\n\nTRUE or FALSE\n\nChoose if the output of a code chunk should be included in the document. FALSE means that your code will run, but will not show up in the document.\n\n\nwarning\n\nTRUE or FALSE\n\nWhether or not you want your output document to display potential warning messages produced by your code.\n\n\nmessage\n\nTRUE or FALSE\n\nWhether or not you want your output document to display potential messages produced by your code.\n\n\nfig.align\n\ndefault, left, right, center\n\nWhere the figure from your R code chunk should be output on the page\n\n\n\n\nTip\n\nThe default settings for the above chunk options are all TRUE.\nThe default settings can be modified per chunk, or with knitr::opts_chunk$set(),\nEntering knitr::opts_chunk$set(echo = FALSE) will change the default of value of echo to FALSE for every code chunk in the document. {: .callout}\n\n\n\nExercise\nPlay around with the different options in the chunk with the code for the table, and re-Knit to see what each option does to the output.\nWhat happens if you use eval = FALSE and echo = FALSE? What is the difference between this and include = FALSE? > ## Solution to Exercise > > Create a chunk with {r eval = FALSE, echo = FALSE}, then create another > chunk with {r include = FALSE} to compare. > eval = FALSE and echo = FALSE will neither run the code in the chunk, > nor show the code in the knitted document. The code chunk essentially > doesn’t exist in the knitted document as it was never run. Whereas > include = FALSE will run the code and store the output for later use. {: .solution} {: .challenge}"
  },
  {
    "objectID": "rmarkdown.html#in-line-r-code",
    "href": "rmarkdown.html#in-line-r-code",
    "title": "R Markdown",
    "section": "In-line R code",
    "text": "In-line R code\nNow we will use some in-line R code to present some descriptive statistics. To use in-line R-code, we use the same backticks that we used in the Markdown section, with an `r` to specify that we are generating R-code. The difference between in-line code and a code chunk is the number of backticks. In-line R code uses one backtick (), whereas code chunks use three backticks (``` r ```).\n\n\n\nFor example, today’s date is 2022-06-30, will be rendered as: today’s date is 2022-06-30. The code will display today’s date in the output document (well, technically the date the document was last knitted).\nThe best way to use in-line R code, is to minimise the amount of code you need to produce the in-line output by preparing the output in code chunks. Let’s say we’re interested in presenting the average household size in a village.\n\n# create a summary data frame with the mean household size by village\nmean_household <- interviews %>%\n    group_by(village) %>%\n    summarize(mean_no_membrs = mean(no_membrs))\n\n# and select the village we want to use\nmean_chirodzo <- mean_household %>%\n  filter(village == \"Chirodzo\")\n\nNow we can make an informative statement on the means of each village, and include the mean values as in-line R-code. For example:\nThe average household size in the village of Chirodzo is r round(mean_chirodzo$mean_no_membrs, 2)\nbecomes…\nThe average household size in the village of Chirodzo is r round(mean_chirodzo$mean_no_membrs, 2).\nBecause we are using in-line R code instead of the actual values, we have created a dynamic document that will automatically update if we make changes to the dataset and/or code chunks."
  },
  {
    "objectID": "rmarkdown.html#plots",
    "href": "rmarkdown.html#plots",
    "title": "R Markdown",
    "section": "Plots",
    "text": "Plots\nFinally, we will also include a plot, so our document is a little more colourful and a little less boring. We will use the interview_plotting data from the previous episode.\nIf you were unable to complete the previous lesson or did not save the data, then you can create it in a new code chunk.\n\n## Not run, but can be used to load in data from previous lesson!\ninterviews_plotting <- interviews %>%\n  ## pivot wider by items_owned\n  separate_rows(items_owned, sep = \";\") %>%\n  ## if there were no items listed, changing NA to no_listed_items\n  replace_na(list(items_owned = \"no_listed_items\")) %>%\n  mutate(items_owned_logical = TRUE) %>%\n  pivot_wider(names_from = items_owned, \n              values_from = items_owned_logical, \n              values_fill = list(items_owned_logical = FALSE)) %>%\n  ## pivot wider by months_lack_food\n  separate_rows(months_lack_food, sep = \";\") %>%\n  mutate(months_lack_food_logical = TRUE) %>%\n  pivot_wider(names_from = months_lack_food, \n              values_from = months_lack_food_logical, \n              values_fill = list(months_lack_food_logical = FALSE)) %>%\n  ## add some summary columns\n  mutate(number_months_lack_food = rowSums(select(., Jan:May))) %>%\n  mutate(number_items = rowSums(select(., bicycle:car)))\n\n\nExercise\nCreate a new code chunk for the plot, and copy the code from any of the plots we created in the previous episode to produce a plot in the chunk. I recommend one of the colourful plots.\nIf you are feeling adventurous, you can also create a new plot with the interviews_plotting data frame.\n\nSolution to Exercise\n\ninterviews_plotting %>%\n  ggplot(aes(x = respondent_wall_type)) +\n  geom_bar(aes(fill = village))\n\n{: .solution} {: .challenge}\n\n\nWe can also create a caption with the chunk option fig.cap.\n```{r chunk-name, fig.cap = \"I made this plot while attending an\nawesome Data Carpentries workshop where I learned a ton of cool stuff!\"}\nCode for plot\n```\n\n…or, ideally, something more informative.\n\ninterviews_plotting %>%\n  ggplot(aes(x = respondent_wall_type)) +\n  geom_bar(aes(fill = village), position = \"dodge\") + \n  labs(x = \"Type of Wall in Home\", y = \"Count\", fill = \"Village Name\") +\n  scale_fill_viridis_d() # add colour deficient friendly palette"
  },
  {
    "objectID": "rmarkdown.html#other-output-options",
    "href": "rmarkdown.html#other-output-options",
    "title": "R Markdown",
    "section": "Other output options",
    "text": "Other output options\nYou can convert R Markdown to a PDF or a Word document (among others). Click the little triangle next to the Knit button to get a drop-down menu. Or you could put pdf_document or word_document in the initial header of the file.\n---\ntitle: \"My Awesome Report\"\nauthor: \"Emmet Brickowski\"\ndate: \"\"\noutput: word_document\n---\n\nNote: Creating PDF documents\nCreating .pdf documents may require installation of some extra software. The R package tinytex provides some tools to help make this process easier for R users. With tinytex installed, run tinytex::install_tinytex() to install the required software (you’ll only need to do this once) and then when you Knit to pdf tinytex will automatically detect and install any additional LaTeX packages that are needed to produce the pdf document. Visit the tinytex website for more information.\n{: .callout}"
  },
  {
    "objectID": "rmarkdown.html#resources",
    "href": "rmarkdown.html#resources",
    "title": "R Markdown",
    "section": "Resources",
    "text": "Resources\n\nKnitr in a knutshell tutorial\n\nDynamic Documents with R and knitr (book)\nR Markdown documentation\nR Markdown cheat sheet\nGetting started with R Markdown\nMarkdown tutorial\n\nR Markdown: The Definitive Guide (book by Rstudio team)\nReproducible Reporting\nThe Ecosystem of R Markdown\nIntroducing Bookdown"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Required Software",
    "section": "",
    "text": "Data Carpentry’s aim is to teach researchers basic concepts, skills, and tools for working with data so that they can get more done in less time, and with less pain. The lessons below were designed for those interested in working with ecology data in R.\nThis is an introduction to R designed for participants with no programming experience. These lessons can be taught in a day (~ 6 hours). They start with some basic information about R syntax, the RStudio interface, and move through how to import CSV files, the structure of data frames, how to deal with factors, how to add/remove rows and columns, how to calculate summary statistics from a data frame, and a brief introduction to plotting. The last lesson demonstrates how to work with databases directly from R.\nThis lesson assumes no prior knowledge of R or RStudio and no programming experience."
  },
  {
    "objectID": "index.html#workshop",
    "href": "index.html#workshop",
    "title": "Required Software",
    "section": "Workshop",
    "text": "Workshop\n\nBefore we start\nIntroduction to R\nStarting with data\nManipulating, analyzing and exporting data with tidyverse\nData visualization with ggplot2"
  },
  {
    "objectID": "index.html#preparations",
    "href": "index.html#preparations",
    "title": "Required Software",
    "section": "Preparations",
    "text": "Preparations\nData Carpentry’s teaching is hands-on, and to follow this lesson learners must have R and RStudio installed on their computers. They also need to be able to install a number of R packages, create directories, and download files.\nTo avoid troubleshooting during the lesson, learners should follow the instruction below to download and install everything beforehand. If they are using their own computers this should be no problem, but if the computer is managed by their organization’s IT department they might need help from an IT administrator.\nInstall R and RStudio\nR and RStudio are two separate pieces of software:\n\n\nR is a programming language that is especially powerful for data exploration, visualization, and statistical analysis\n\nRStudio is an integrated development environment (IDE) that makes using R easier. In this course we use RStudio to interact with\n\n\n\n\n\nIf you don’t already have R and RStudio installed, follow the instructions for your operating system below. You have to install R before you install RStudio.\nWindows\n\nDownload R from the CRAN website.\nRun the .exe file that was just downloaded\nGo to the RStudio download page\n\nUnder Installers select RStudio x.yy.zzz - Windows Vista/7/8/10 (where x, y, and z represent version numbers)\nDouble click the file to install it\nOnce it’s installed, open RStudio to make sure it works and you don’t get any error messages.\n\n\n\n\n\n\n\nUWA Laptop Users\n\n\n\nIf you are using a UWA provided laptop, the ‘Documents’ folder (where R / RStudio normally stores files) will be a network-mapped drive. This will cause the installation and use of R packages to be VERY VERY SLOW.\nSolution:\nYou will need to create a folder for installing packages that will be kept only on your local machine, potentially just the desktop or another non-network folder.\nFor example:\nC:\\Users\\bradyjohnston\\Desktop\\R\\win-library\nor\nC:\\Users\\bradyjohnston\\R\\win-library\nThen create a file called .Renviron in your home directory, for me it would be:\nC:\\Users\\bradyjohnston\\\nInside of this file, include a single line that specifies the folder you created where you wish to install your packages:\nR_LIBS_USER=C:\\Users\\bradyjohnston\\Desktop\\R\\win-library\nThis should enable quick install of packages.\n\n\n\nMacOS\n\nDownload R from the CRAN website.\nSelect the .pkg file for the latest R version\nDouble click on the downloaded file to install R\nIt is also a good idea to install XQuartz (needed by some packages)\nGo to the RStudio download page\n\nUnder Installers select RStudio x.yy.zzz - Mac OS X 10.6+ (64-bit) (where x, y, and z represent version numbers)\nDouble click the file to install RStudio\nOnce it’s installed, open RStudio to make sure it works and you don’t get any error messages.\nLinux\n\nFollow the instructions for your distribution from CRAN, they provide information to get the most recent version of R for common distributions. For most distributions, you could use your package manager (e.g., for Debian/Ubuntu run sudo apt-get install r-base, and for Fedora sudo yum install R), but we don’t recommend this approach as the versions provided by this are usually out of date. In any case, make sure you have at least R 3.3.1.\nGo to the RStudio download page\n\nUnder Installers select the version that matches your distribution, and install it with your preferred method (e.g., with Debian/Ubuntu sudo dpkg -i   rstudio-x.yy.zzz-amd64.deb at the terminal).\nOnce it’s installed, open RStudio to make sure it works and you don’t get any error messages.\nUpdate R and RStudio\nIf you already have R and RStudio installed, first check if your R version is up to date:\n\nWhen you open RStudio your R version will be printed in the console on the bottom left. Alternatively, you can type sessionInfo() into the console. If your R version is 4.0.0 or later, you don’t need to update R for this lesson. If your version of R is older than that, download and install the latest version of R from the R project website for Windows, for MacOS, or for Linux\n\nIt is not necessary to remove old versions of R from your system, but if you wish to do so you can check How do I uninstall R?\n\nNote: The changes introduced by new R versions are usually backwards-compatible. That is, your old code should still work after updating your R version. However, if breaking changes happen, it is useful to know that you can have multiple versions of R installed in parallel and that you can switch between them in RStudio by going to Tools > Global Options > General > Basic.\nAfter installing a new version of R, you will have to reinstall all your packages with the new version. For Windows, there is a package called installr that can help you with upgrading your R version and migrate your package library.\n\nTo update RStudio to the latest version, open RStudio and click on Help > Check for Updates. If a new version is available follow the instruction on screen. By default, RStudio will also automatically notify you of new versions every once in a while.\nInstall required R packages\nDuring the course we will need a number of R packages. Packages contain useful R code written by other people. We will use the packages tidyverse, hexbin, patchwork, and RSQLite.\nTo try to install these packages, open RStudio and copy and paste the following command into the console window (look for a blinking cursor on the bottom left), then press the Enter (Windows and Linux) or Return (MacOS) to execute the command.\n\ninstall.packages(c(\"tidyverse\", \"hexbin\", \"patchwork\", \"RSQLite\"))\n\nAlternatively, you can install the packages using RStudio’s graphical user interface by going to Tools > Install Packages and typing the names of the packages separated by a comma.\nR tries to download and install the packages on your machine. When the installation has finished, you can try to load the packages by pasting the following code into the console:\n\nlibrary(tidyverse)\nlibrary(hexbin)\nlibrary(patchwork)\nlibrary(RSQLite)\n\nIf you do not see an error like there is no package called ‘...’ you are good to go!\nUpdating R packages\nGenerally, it is recommended to keep your R version and all packages up to date, because new versions bring improvements and important bugfixes. To update the packages that you have installed, click Update in the Packages tab in the bottom right panel of RStudio, or go to Tools > Check for Package Updates....\nSometimes, package updates introduce changes that break your old code, which can be very frustrating. To avoid this problem, you can use a package called renv. It locks the package versions you have used for a given project and makes it straightforward to reinstall those exact package version in a new environment, for example after updating your R version or on another computer. However, the details are outside of the scope of this lesson.\nDownload the data\nWe will download the data directly from R during the lessons. However, if you are expecting problems with the network, it may be better to download the data beforehand and store it on your machine.\nThe data files for the lesson can be downloaded manually here: https://doi.org/10.6084/m9.figshare.1314459"
  },
  {
    "objectID": "index.html#contributors",
    "href": "index.html#contributors",
    "title": "Required Software",
    "section": "Contributors",
    "text": "Contributors\nThe list of contributors to this lesson is available here.\n\nPage built on: 📆 2022-06-29 ‒ 🕢 15:36:43"
  }
]