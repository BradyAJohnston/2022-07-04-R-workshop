[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "2022-07-04-R-workshop",
    "section": "",
    "text": "All Data Carpentry instructional material is made available under the Creative Commons Attribution license. You are free:\n\nto Share‚Äîto copy, distribute and transmit the work\nto Remix‚Äîto adapt the work\n\nUnder the following conditions:\n\nAttribution‚ÄîYou must attribute the work using ‚ÄúCopyright (c) Data Carpentry‚Äù (but not in any way that suggests that we endorse you or your use of the work). Where practical, you must also include a hyperlink to https://datacarpentry.org.\n\nWith the understanding that:\n\nWaiver‚ÄîAny of the above conditions can be waived if you get permission from the copyright holder.\nOther Rights‚ÄîIn no way are any of the following rights affected by the license:\n\nYour fair dealing or fair use rights;\nThe author‚Äôs moral rights;\nRights other persons may have either in the work itself or in how the work is used, such as publicity or privacy rights. *\n\nNotice‚ÄîFor any reuse or distribution, you must make clear to others the license terms of this work. The best way to do this is with a link to https://creativecommons.org/licenses/by/4.0/.\n\nFor the full legal text of this license, please see https://creativecommons.org/licenses/by/4.0/legalcode.\n\n\n\nExcept where otherwise noted, the example programs and other software provided by Data Carpentry are made available under the OSI-approved MIT license.\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nPage built on: üìÜ 2022-06-28 ‚Äí üï¢ 12:11:35"
  },
  {
    "objectID": "01-intro-to-r.html#creating-objects-in-r",
    "href": "01-intro-to-r.html#creating-objects-in-r",
    "title": "Introduction to R",
    "section": "\n1 Creating objects in R",
    "text": "1 Creating objects in R\n\n\n\nYou can get output from R simply by typing math in the console:\n\n3 + 5\n12 / 7\n\nHowever, to do useful and interesting things, we need to assign values to objects. To create an object, we need to give it a name followed by the assignment operator <-, and the value we want to give it:\n\nweight_kg <- 55\n\n<- is the assignment operator. It assigns values on the right to objects on the left. So, after executing x <- 3, the value of x is 3. For historical reasons, you can also use = for assignments, but not in every context. Because of the slight differences in syntax, it is good practice to always use <- for assignments.\nIn RStudio, typing Alt + - (push Alt at the same time as the - key) will write <- in a single keystroke in a PC, while typing Option + - (push Option at the same time as the - key) does the same in a Mac.\nObjects can be given almost any name such as x, current_temperature, or subject_id. Here are some further guidelines on naming objects:\n\nYou want your object names to be explicit and not too long.\nThey cannot start with a number (2x is not valid, but x2 is).\nR is case sensitive, so for example, weight_kg is different from Weight_kg.\nThere are some names that cannot be used because they are the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it‚Äôs allowed, it‚Äôs best to not use other function names (e.g., c, T, mean, data, df, weights). If in doubt, check the help to see if the name is already in use.\nIt‚Äôs best to avoid dots (.) within names. Many function names in R itself have them and dots also have a special meaning (methods) in R and other programming languages. To avoid confusion, don‚Äôt include dots in names.\nIt is recommended to use nouns for object names and verbs for function names.\nBe consistent in the styling of your code, such as where you put spaces, how you name objects, etc. Styles can include ‚Äúlower_snake‚Äù, ‚ÄúUPPER_SNAKE‚Äù, ‚ÄúlowerCamelCase‚Äù, ‚ÄúUpperCamelCase‚Äù, etc. Using a consistent coding style makes your code clearer to read for your future self and your collaborators. In R, three popular style guides come from Google, Jean Fan and the tidyverse. The tidyverse style is very comprehensive and may seem overwhelming at first. You can install the lintr package to automatically check for issues in the styling of your code.\n\n\n\n1.1 Objects vs.¬†variables\nWhat are known as objects in R are known as variables in many other programming languages. Depending on the context, object and variable can have drastically different meanings. However, in this lesson, the two words are used synonymously. For more information see: https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects\n\nWhen assigning a value to an object, R does not print anything. You can force R to print the value by using parentheses or by typing the object name:\n\nweight_kg <- 55    # doesn't print anything\n(weight_kg <- 55)  # but putting parenthesis around the call prints the value of `weight_kg`\nweight_kg          # and so does typing the name of the object\n\nNow that R has weight_kg in memory, we can do arithmetic with it. For instance, we may want to convert this weight into pounds (weight in pounds is 2.2 times the weight in kg):\n\n2.2 * weight_kg\n\nWe can also change an object‚Äôs value by assigning it a new one:\n\nweight_kg <- 57.5\n2.2 * weight_kg\n\nThis means that assigning a value to one object does not change the values of other objects. For example, let‚Äôs store the animal‚Äôs weight in pounds in a new object, weight_lb:\n\nweight_lb <- 2.2 * weight_kg\n\nand then change weight_kg to 100.\n\nweight_kg <- 100\n\nWhat do you think is the current content of the object weight_lb? 126.5 or 220?\n\n1.2 Saving your code\nUp to now, your code has been in the console. This is useful for quick queries but not so helpful if you want to revisit your work for any reason. A script can be opened by pressing Ctrl + Shift + N. It is wise to save your script file immediately. To do this press Ctrl + S. This will open a dialogue box where you can decide where to save your script file, and what to name it. The .R file extension is added automatically and ensures your file will open with RStudio.\nDon‚Äôt forget to save your work periodically by pressing Ctrl + S.\n\n1.3 Comments\nThe comment character in R is #. Anything to the right of a # in a script will be ignored by R. It is useful to leave notes and explanations in your scripts. For convenience, RStudio provides a keyboard shortcut to comment or uncomment a paragraph: after selecting the lines you want to comment, press at the same time on your keyboard Ctrl + Shift + C. If you only want to comment out one line, you can put the cursor at any location of that line (i.e.¬†no need to select the whole line), then press Ctrl + Shift + C.\n\n\n1.4 Challenge\nWhat are the values after each statement in the following?\n\nmass <- 47.5            # mass?\nage  <- 122             # age?\nmass <- mass * 2.0      # mass?\nage  <- age - 20        # age?\nmass_index <- mass/age  # mass_index?\n\n\n\n\n\n\n1.5 Functions and their arguments\nFunctions are ‚Äúcanned scripts‚Äù that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually takes one or more inputs called arguments. Functions often (but not always) return a value. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number. Executing a function (‚Äòrunning it‚Äô) is called calling the function. An example of a function call is:\n\nweight_kg <- sqrt(10)\n\nHere, the value of 10 is given to the sqrt() function, the sqrt() function calculates the square root, and returns the value which is then assigned to the object weight_kg. This function takes one argument, other functions might take several.\nThe return ‚Äòvalue‚Äô of a function need not be numerical (like that of sqrt()), and it also does not need to be a single item: it can be a set of things, or even a dataset. We‚Äôll see that when we read data files into R.\nArguments can be anything, not only numbers or filenames, but also other objects. Exactly what each argument means differs per function, and must be looked up in the documentation (see below). Some functions take arguments which may either be specified by the user, or, if left out, take on a default value: these are called options. Options are typically used to alter the way the function operates, such as whether it ignores ‚Äòbad values‚Äô, or what symbol to use in a plot. However, if you want something specific, you can specify a value of your choice which will be used instead of the default.\nLet‚Äôs try a function that can take multiple arguments: round().\n\nround(3.14159)\n\n#> [1] 3\n\n\nHere, we‚Äôve called round() with just one argument, 3.14159, and it has returned the value 3. That‚Äôs because the default is to round to the nearest whole number. If we want more digits we can see how to do that by getting information about the round function. We can use args(round) to find what arguments it takes, or look at the help for this function using ?round.\n\nargs(round)\n\n#> function (x, digits = 0) \n#> NULL\n\n\n\n?round\n\nWe see that if we want a different number of digits, we can type digits = 2 or however many we want.\n\nround(3.14159, digits = 2)\n\n#> [1] 3.14\n\n\nIf you provide the arguments in the exact same order as they are defined you don‚Äôt have to name them:\n\nround(3.14159, 2)\n\n#> [1] 3.14\n\n\nAnd if you do name the arguments, you can switch their order:\n\nround(digits = 2, x = 3.14159)\n\n#> [1] 3.14\n\n\nIt‚Äôs good practice to put the non-optional arguments (like the number you‚Äôre rounding) first in your function call, and to then specify the names of all optional arguments. If you don‚Äôt, someone reading your code might have to look up the definition of a function with unfamiliar arguments to understand what you‚Äôre doing."
  },
  {
    "objectID": "01-intro-to-r.html#vectors-and-data-types",
    "href": "01-intro-to-r.html#vectors-and-data-types",
    "title": "Introduction to R",
    "section": "\n2 Vectors and data types",
    "text": "2 Vectors and data types\n\n\n\nA vector is the most common and basic data type in R, and is pretty much the workhorse of R. A vector is composed by a series of values, which can be either numbers or characters. We can assign a series of values to a vector using the c() function. For example we can create a vector of animal weights and assign it to a new object weight_g:\n\nweight_g <- c(50, 60, 65, 82)\nweight_g\n\nA vector can also contain characters:\n\nanimals <- c(\"mouse\", \"rat\", \"dog\")\nanimals\n\nThe quotes around ‚Äúmouse‚Äù, ‚Äúrat‚Äù, etc. are essential here. Without the quotes R will assume objects have been created called mouse, rat and dog. As these objects don‚Äôt exist in R‚Äôs memory, there will be an error message.\nThere are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector:\n\nlength(weight_g)\nlength(animals)\n\nAn important feature of a vector, is that all of the elements are the same type of data. The function class() indicates what kind of object you are working with:\n\nclass(weight_g)\nclass(animals)\n\nThe function str() provides an overview of the structure of an object and its elements. It is a useful function when working with large and complex objects:\n\nstr(weight_g)\nstr(animals)\n\nYou can use the c() function to add other elements to your vector:\n\nweight_g <- c(weight_g, 90) # add to the end of the vector\nweight_g <- c(30, weight_g) # add to the beginning of the vector\nweight_g\n\nIn the first line, we take the original vector weight_g, add the value 90 to the end of it, and save the result back into weight_g. Then we add the value 30 to the beginning, again saving the result back into weight_g.\nWe can do this over and over again to grow a vector, or assemble a dataset. As we program, this may be useful to add results that we are collecting or calculating.\nAn atomic vector is the simplest R data type and is a linear vector of a single type. Above, we saw 2 of the 6 main atomic vector types that R uses: \"character\" and \"numeric\" (or \"double\"). These are the basic building blocks that all R objects are built from. The other 4 atomic vector types are:\n\n\n\"logical\" for TRUE and FALSE (the boolean data type)\n\n\"integer\" for integer numbers (e.g., 2L, the L indicates to R that it‚Äôs an integer)\n\n\"complex\" to represent complex numbers with real and imaginary parts (e.g., 1 + 4i) and that‚Äôs all we‚Äôre going to say about them\n\n\"raw\" for bitstreams that we won‚Äôt discuss further\n\nYou can check the type of your vector using the typeof() function and inputting your vector as the argument.\nVectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), data frames (data.frame), factors (factor) and arrays (array).\n\n\n2.1 Challenge\n\nWe‚Äôve seen that atomic vectors can be of type character, numeric (or double), integer, and logical. But what happens if we try to mix these types in a single vector?\n\n::: {.cell hash=‚Äò01-intro-to-r_cache/html/unnamed-chunk-26_599e63993e9d552e6949e82da19897fc‚Äô}\n\n\nAnswer\n\n\n\nR implicitly converts them to all be the same type\n\n\n\n\n:::\n\n\nWhat will happen in each of these examples? (hint: use class() to check the data type of your objects):\nnum_char <- c(1, 2, 3, \"a\")\nnum_logical <- c(1, 2, 3, TRUE)\nchar_logical <- c(\"a\", \"b\", \"c\", TRUE)\ntricky <- c(1, 2, 3, \"4\")\n\nWhy do you think it happens?\n\n::: {.cell hash=‚Äò01-intro-to-r_cache/html/unnamed-chunk-27_ca7d92a10e56b9ecbba0500f69e0604e‚Äô}\n\n\nAnswer\n\n\n\nVectors can be of only one data type. R tries to convert (coerce) the content of this vector to find a ‚Äúcommon denominator‚Äù that doesn‚Äôt lose any information.\n\n\n\n\n:::\n\n\nHow many values in combined_logical are \"TRUE\" (as a character) in the following example (reusing the 2 ..._logicals from above):\ncombined_logical <- c(num_logical, char_logical)\n\n\n::: {.cell hash=‚Äò01-intro-to-r_cache/html/unnamed-chunk-28_c47de4534d3fc0b89f828d4d6dc9d7bb‚Äô}\n\n\nAnswer\n\n\n\nOnly one. There is no memory of past data types, and the coercion happens the first time the vector is evaluated. Therefore, the TRUE in num_logical gets converted into a 1 before it gets converted into \"1\" in combined_logical.\n\n\n\n\n:::\n\nYou‚Äôve probably noticed that objects of different types get converted into a single, shared type within a vector. In R, we call converting objects from one class into another class coercion. These conversions happen according to a hierarchy, whereby some types get preferentially coerced into other types. Can you draw a diagram that represents the hierarchy of how these data types are coerced?\n\n::: {.cell hash=‚Äò01-intro-to-r_cache/html/unnamed-chunk-29_0a22382dd644ef7edb155f35bfe0e090‚Äô}\n\n\nAnswer\n\n\n\nlogical ‚Üí numeric ‚Üí character ‚Üê logical\n\n\n\n\n:::"
  },
  {
    "objectID": "01-intro-to-r.html#subsetting-vectors",
    "href": "01-intro-to-r.html#subsetting-vectors",
    "title": "Introduction to R",
    "section": "\n3 Subsetting vectors",
    "text": "3 Subsetting vectors\nIf we want to extract one or several values from a vector, we must provide one or several indices in square brackets. For instance:\n\nanimals <- c(\"mouse\", \"rat\", \"dog\", \"cat\")\nanimals[2]\n\n#> [1] \"rat\"\n\nanimals[c(3, 2)]\n\n#> [1] \"dog\" \"rat\"\n\n\nWe can also repeat the indices to create an object with more elements than the original one:\n\nmore_animals <- animals[c(1, 2, 3, 2, 1, 4)]\nmore_animals\n\n#> [1] \"mouse\" \"rat\"   \"dog\"   \"rat\"   \"mouse\" \"cat\"\n\n\nR indices start at 1. Programming languages like Fortran, MATLAB, Julia, and R start counting at 1, because that‚Äôs what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that‚Äôs simpler for computers to do.\n\n3.1 Conditional subsetting\nAnother common way of subsetting is by using a logical vector. TRUE will select the element with the same index, while FALSE will not:\n\nweight_g <- c(21, 34, 39, 54, 55)\nweight_g[c(TRUE, FALSE, FALSE, TRUE, TRUE)]\n\n#> [1] 21 54 55\n\n\nTypically, these logical vectors are not typed by hand, but are the output of other functions or logical tests. For instance, if you wanted to select only the values above 50:\n\nweight_g > 50    # will return logicals with TRUE for the indices that meet the condition\n\n#> [1] FALSE FALSE FALSE  TRUE  TRUE\n\n## so we can use this to select only the values above 50\nweight_g[weight_g > 50]\n\n#> [1] 54 55\n\n\nYou can combine multiple tests using & (both conditions are true, AND) or | (at least one of the conditions is true, OR):\n\nweight_g[weight_g > 30 & weight_g < 50]\n\n#> [1] 34 39\n\nweight_g[weight_g <= 30 | weight_g == 55]\n\n#> [1] 21 55\n\nweight_g[weight_g >= 30 & weight_g == 21]\n\n#> numeric(0)\n\n\nHere, > for ‚Äúgreater than‚Äù, < stands for ‚Äúless than‚Äù, <= for ‚Äúless than or equal to‚Äù, and == for ‚Äúequal to‚Äù. The double equal sign == is a test for numerical equality between the left and right hand sides, and should not be confused with the single = sign, which performs variable assignment (similar to <-).\nA common task is to search for certain strings in a vector. One could use the ‚Äúor‚Äù operator | to test for equality to multiple values, but this can quickly become tedious. The function %in% allows you to test if any of the elements of a search vector are found:\n\nanimals <- c(\"mouse\", \"rat\", \"dog\", \"cat\", \"cat\")\n\n# return both rat and cat\nanimals[animals == \"cat\" | animals == \"rat\"]\n\n#> [1] \"rat\" \"cat\" \"cat\"\n\n# return a logical vector that is TRUE for the elements within animals\n# that are found in the character vector and FALSE for those that are not\nanimals %in% c(\"rat\", \"cat\", \"dog\", \"duck\", \"goat\", \"bird\", \"fish\")\n\n#> [1] FALSE  TRUE  TRUE  TRUE  TRUE\n\n# use the logical vector created by %in% to return elements from animals\n# that are found in the character vector\nanimals[animals %in% c(\"rat\", \"cat\", \"dog\", \"duck\", \"goat\", \"bird\", \"fish\")]\n\n#> [1] \"rat\" \"dog\" \"cat\" \"cat\"\n\n\n\n\n3.2 Challenge (optional)\n\nCan you figure out why \"four\" > \"five\" returns TRUE?\n\n::: {.cell hash=‚Äò01-intro-to-r_cache/html/unnamed-chunk-37_0ecb67ca9a8f47e44de11c83360a9fa7‚Äô}\n\n\nAnswer\n\n\n\nWhen using ‚Äú>‚Äù or ‚Äú<‚Äù on strings, R compares their alphabetical order. Here ‚Äúfour‚Äù comes after ‚Äúfive‚Äù, and therefore is ‚Äúgreater than‚Äù it.\n\n\n\n\n:::"
  },
  {
    "objectID": "01-intro-to-r.html#missing-data",
    "href": "01-intro-to-r.html#missing-data",
    "title": "Introduction to R",
    "section": "\n4 Missing data",
    "text": "4 Missing data\nAs R was designed to analyze datasets, it includes the concept of missing data (which is uncommon in other programming languages). Missing data are represented in vectors as NA.\nWhen doing operations on numbers, most functions will return NA if the data you are working with include missing values. This feature makes it harder to overlook the cases where you are dealing with missing data. You can add the argument na.rm = TRUE to calculate the result as if the missing values were removed (rm stands for ReMoved) first.\n\nheights <- c(2, 4, 4, NA, 6)\nmean(heights)\nmax(heights)\nmean(heights, na.rm = TRUE)\nmax(heights, na.rm = TRUE)\n\nIf your data include missing values, you may want to become familiar with the functions is.na(), na.omit(), and complete.cases(). See below for examples.\n\n## Extract those elements which are not missing values.\nheights[!is.na(heights)]\n\n## Returns the object with incomplete cases removed.\n#The returned object is an atomic vector of type `\"numeric\"` (or #`\"double\"`).\nna.omit(heights)\n\n## Extract those elements which are complete cases.\n#The returned object is an atomic vector of type `\"numeric\"` (or #`\"double\"`).\nheights[complete.cases(heights)]\n\nRecall that you can use the typeof() function to find the type of your atomic vector.\n\n\n4.1 Challenge\n\n\nUsing this vector of heights in inches, create a new vector, heights_no_na, with the NAs removed.\nheights <- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)\n\nUse the function median() to calculate the median of the heights vector.\nUse R to figure out how many people in the set are taller than 67 inches.\n\n\n\n\nAnswer\n\n\nheights <- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)\n\n# 1.\nheights_no_na <- heights[!is.na(heights)]\n# or\nheights_no_na <- na.omit(heights)\n# or\nheights_no_na <- heights[complete.cases(heights)]\n\n# 2.\nmedian(heights, na.rm = TRUE)\n\n# 3.\nheights_above_67 <- heights_no_na[heights_no_na > 67]\nlength(heights_above_67)\n\n\n\n\n\n\n\nNow that we have learned how to write scripts, and the basics of R‚Äôs data structures, we are ready to start working with the Portal dataset we have been using in the other lessons, and learn about data frames.\n\nPage built on: üìÜ 2022-06-28 ‚Äí üï¢ 12:11:39"
  },
  {
    "objectID": "CONDUCT.html",
    "href": "CONDUCT.html",
    "title": "2022-07-04-R-workshop",
    "section": "",
    "text": "As contributors and maintainers of this project, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.\nWe are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, or religion.\nExamples of unacceptable behavior by participants include the use of sexual language or imagery, derogatory comments or personal attacks, trolling, public or private harassment, insults, or other unprofessional conduct.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to our Code of Conduct. Project maintainers who do not follow the Code of Conduct may be removed from the project team.\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by following our reporting guidelines.\n\nPage built on: üìÜ 2022-06-28 ‚Äí üï¢ 12:11:41"
  },
  {
    "objectID": "04-visualization-ggplot2.html",
    "href": "04-visualization-ggplot2.html",
    "title": "Data visualization with ggplot2",
    "section": "",
    "text": "We start by loading the required packages. ggplot2 is included in the tidyverse package.\nIf not still in the workspace, load the data we saved in the previous lesson."
  },
  {
    "objectID": "04-visualization-ggplot2.html#plotting-with-ggplot2",
    "href": "04-visualization-ggplot2.html#plotting-with-ggplot2",
    "title": "Data visualization with ggplot2",
    "section": "1 Plotting with ggplot2",
    "text": "1 Plotting with ggplot2\nggplot2 is a plotting package that provides helpful commands to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.\nggplot2 refers to the name of the package itself. When using the package we use the function ggplot() to generate the plots, and so references to using the function will be referred to as ggplot() and the package as a whole as ggplot2\nggplot2 plots work best with data in the ‚Äòlong‚Äô format, i.e., a column for every variable, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2\nggplot graphics are built layer by layer by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\nggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()\n\nuse the ggplot() function and bind the plot to a specific data frame using the data argument\n\n\nggplot(data = surveys_complete)\n\n\ndefine an aesthetic mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g., as x/y positions or characteristics such as size, shape, color, etc.\n\n\nggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length))\n\n\nadd ‚Äògeoms‚Äô ‚Äì graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use some common ones today, including:\n\ngeom_point() for scatter plots, dot plots, etc.\ngeom_boxplot() for, well, boxplots!\ngeom_line() for trend lines, time series, etc.\n\n\nTo add a geom to the plot use + operator. Because we have two continuous variables, let‚Äôs use geom_point() first:\n\nggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +\n  geom_point()\n\n\n\n\nThe + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot ‚Äútemplates‚Äù and conveniently explore different types of plots, so the above plot can also be generated with code like this:\n\n# Assign plot to a variable\nsurveys_plot <- ggplot(data = surveys_complete,\n                       mapping = aes(x = weight, y = hindfoot_length))\n\n# Draw the plot\nsurveys_plot +\n    geom_point()\n\n\n\n\nNotes\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are universal plot settings). This includes the x- and y-axis you set up in aes().\nYou can also specify aesthetics for a given geom independently of the aesthetics defined globally in the ggplot() function.\nThe + sign used to add layers must be placed at the end of each line containing a layer. If, instead, the + sign is added in the line before the other layer, ggplot2 will not add the new layer and will return an error message.\nYou may notice that we sometimes reference ‚Äòggplot2‚Äô and sometimes ‚Äòggplot‚Äô. To clarify, ‚Äòggplot2‚Äô is the name of the most recent version of the package. However, any time we call the function itself, it‚Äôs just called ‚Äòggplot‚Äô.\nThe previous version of the ggplot2 package, called ggplot, which also contained the ggplot() function is now unsupported and has been removed from CRAN in order to reduce accidental installations and further confusion.\n\n\n# This is the correct syntax for adding layers\nsurveys_plot +\n  geom_point()\n\n# This will not add the new layer and will return an error message\nsurveys_plot\n  + geom_point()\n\n\n1.1 Challenge (optional)\nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the surveys_complete data set, overplotting of points can be a limitation of scatter plots. One strategy for handling such settings is to use hexagonal binning of observations. The plot space is tessellated into hexagons. Each hexagon is assigned a color based on the number of observations that fall within its boundaries. To use hexagonal binning with ggplot2, first install the R package hexbin from CRAN:\n\ninstall.packages(\"hexbin\")\nlibrary(hexbin)\n\nThen use the geom_hex() function:\n\nsurveys_plot +\n geom_hex()\n\n\nWhat are the relative strengths and weaknesses of a hexagonal bin plot compared to a scatter plot? Examine the above scatter plot and compare it with the hexagonal bin plot that you created."
  },
  {
    "objectID": "04-visualization-ggplot2.html#building-your-plots-iteratively",
    "href": "04-visualization-ggplot2.html#building-your-plots-iteratively",
    "title": "Data visualization with ggplot2",
    "section": "2 Building your plots iteratively",
    "text": "2 Building your plots iteratively\nBuilding plots with ggplot2 is typically an iterative process. We start by defining the dataset we‚Äôll use, lay out the axes, and choose a geom:\n\nggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +\n    geom_point()\n\n\n\n\nThen, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1)\n\n\n\n\nWe can also add colors for all the points:\n\nggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1, color = \"blue\")\n\n\n\n\nOr to color each species in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with species_id:\n\nggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1, aes(color = species_id))\n\n\n\n\n\n2.1 Challenge\nUse what you just learned to create a scatter plot of weight over species_id with the plot types showing in different colors. Is this a good way to show this type of data?\n\n\n\nAnswer\n\n\nggplot(data = surveys_complete,\n       mapping = aes(x = species_id, y = weight)) +\n   geom_point(aes(color = plot_type))"
  },
  {
    "objectID": "04-visualization-ggplot2.html#boxplot",
    "href": "04-visualization-ggplot2.html#boxplot",
    "title": "Data visualization with ggplot2",
    "section": "3 Boxplot",
    "text": "3 Boxplot\nWe can use boxplots to visualize the distribution of weight within each species:\n\nggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +\n    geom_boxplot()\n\n\n\n\nBy adding points to the boxplot, we can have a better idea of the number of measurements and of their distribution:\n\nggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +\n    geom_boxplot(alpha = 0) +\n    geom_jitter(alpha = 0.3, color = \"tomato\")\n\n\n\n\nNotice how the boxplot layer is behind the jitter layer? What do you need to change in the code to put the boxplot in front of the points such that it‚Äôs not hidden?\n\n3.1 Challenges\nBoxplots are useful summaries, but hide the shape of the distribution. For example, if there is a bimodal distribution, it would not be observed with a boxplot. An alternative to the boxplot is the violin plot (sometimes known as a beanplot), where the shape (of the density of points) is drawn.\n\nReplace the box plot with a violin plot; see geom_violin().\n\nIn many types of data, it is important to consider the scale of the observations. For example, it may be worth changing the scale of the axis to better distribute the observations in the space of the plot. Changing the scale of the axes is done similarly to adding/modifying other components (i.e., by incrementally adding commands). Try making these modifications:\n\nRepresent weight on the log10 scale; see scale_y_log10().\n\nSo far, we‚Äôve looked at the distribution of weight within species. Try making a new plot to explore the distribution of another variable within each species.\n\nCreate boxplot for hindfoot_length. Overlay the boxplot layer on a jitter layer to show actual measurements.\nAdd color to the data points on your boxplot according to the plot from which the sample was taken (plot_id).\n\n\n\nHint: Check the class for plot_id. Consider changing the class of plot_id from integer to factor. Why does this change how R makes the graph?"
  },
  {
    "objectID": "04-visualization-ggplot2.html#plotting-time-series-data",
    "href": "04-visualization-ggplot2.html#plotting-time-series-data",
    "title": "Data visualization with ggplot2",
    "section": "4 Plotting time series data",
    "text": "4 Plotting time series data\nLet‚Äôs calculate number of counts per year for each genus. First we need to group the data and count records within each group:\n\nyearly_counts <- surveys_complete %>%\n  count(year, genus)\n\nTimelapse data can be visualized as a line plot with years on the x-axis and counts on the y-axis:\n\nggplot(data = yearly_counts, aes(x = year, y = n)) +\n     geom_line()\n\n\n\n\nUnfortunately, this does not work because we plotted data for all the genera together. We need to tell ggplot to draw a line for each genus by modifying the aesthetic function to include group = genus:\n\nggplot(data = yearly_counts, aes(x = year, y = n, group = genus)) +\n    geom_line()\n\n\n\n\nWe will be able to distinguish genera in the plot if we add colors (using color also automatically groups the data):\n\nggplot(data = yearly_counts, aes(x = year, y = n, color = genus)) +\n    geom_line()"
  },
  {
    "objectID": "04-visualization-ggplot2.html#integrating-the-pipe-operator-with-ggplot2",
    "href": "04-visualization-ggplot2.html#integrating-the-pipe-operator-with-ggplot2",
    "title": "Data visualization with ggplot2",
    "section": "5 Integrating the pipe operator with ggplot2",
    "text": "5 Integrating the pipe operator with ggplot2\nIn the previous lesson, we saw how to use the pipe operator %>% to use different functions in a sequence and create a coherent workflow. We can also use the pipe operator to pass the data argument to the ggplot() function. The hard part is to remember that to build your ggplot, you need to use + and not %>%.\n\nyearly_counts %>%\n    ggplot(mapping = aes(x = year, y = n, color = genus)) +\n    geom_line()\n\n\n\n\nThe pipe operator can also be used to link data manipulation with consequent data visualization.\n\nyearly_counts_graph <- surveys_complete %>%\n    count(year, genus) %>%\n    ggplot(mapping = aes(x = year, y = n, color = genus)) +\n    geom_line()\n\nyearly_counts_graph"
  },
  {
    "objectID": "04-visualization-ggplot2.html#faceting",
    "href": "04-visualization-ggplot2.html#faceting",
    "title": "Data visualization with ggplot2",
    "section": "6 Faceting",
    "text": "6 Faceting\nggplot has a special technique called faceting that allows the user to split one plot into multiple plots based on a factor included in the dataset. We will use it to make a time series plot for each genus:\n\nggplot(data = yearly_counts, aes(x = year, y = n)) +\n    geom_line() +\n    facet_wrap(facets = vars(genus))\n\n\n\n\nNow we would like to split the line in each plot by the sex of each individual measured. To do that we need to make counts in the data frame grouped by year, genus, and sex:\n\n yearly_sex_counts <- surveys_complete %>%\n                      count(year, genus, sex)\n\nWe can now make the faceted plot by splitting further by sex using color (within a single plot):\n\nggplot(data = yearly_sex_counts, mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_wrap(facets =  vars(genus))\n\n\n\n\nWe can also facet both by sex and genus:\n\nggplot(data = yearly_sex_counts,\n       mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_grid(rows = vars(sex), cols =  vars(genus))\n\n\n\n\nYou can also organise the panels only by rows (or only by columns):\n\n# One column, facet by rows\nggplot(data = yearly_sex_counts,\n       mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_grid(rows = vars(genus))\n\n\n\n\n\n# One row, facet by column\nggplot(data = yearly_sex_counts,\n       mapping = aes(x = year, y = n, color = sex)) +\n  geom_line() +\n  facet_grid(cols = vars(genus))\n\n\n\n\nNote: ggplot2 before version 3.0.0 used formulas to specify how plots are faceted. If you encounter facet_grid/wrap(...) code containing ~, please read https://ggplot2.tidyverse.org/news/#tidy-evaluation."
  },
  {
    "objectID": "04-visualization-ggplot2.html#ggplot2-themes",
    "href": "04-visualization-ggplot2.html#ggplot2-themes",
    "title": "Data visualization with ggplot2",
    "section": "7 ggplot2 themes",
    "text": "7 ggplot2 themes\nUsually plots with white background look more readable when printed. Every single component of a ggplot graph can be customized using the generic theme() function, as we will see below. However, there are pre-loaded themes available that change the overall appearance of the graph without much effort.\nFor example, we can change our previous graph to have a simpler white background using the theme_bw() function:\n\n ggplot(data = yearly_sex_counts,\n        mapping = aes(x = year, y = n, color = sex)) +\n     geom_line() +\n     facet_wrap(vars(genus)) +\n     theme_bw()\n\n\n\n\nIn addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme.\nThe ggthemes package provides a wide variety of options.\n\n7.1 Challenge\nUse what you just learned to create a plot that depicts how the average weight of each species changes through the years.\n\n\n\nAnswer\n\n\nyearly_weight <- surveys_complete %>%\n                group_by(year, species_id) %>%\n                 summarize(avg_weight = mean(weight))\n\n#> `summarise()` has grouped output by 'year'. You can override using the\n#> `.groups` argument.\n\nggplot(data = yearly_weight, mapping = aes(x=year, y=avg_weight)) +\n   geom_line() +\n   facet_wrap(vars(species_id)) +\n   theme_bw()"
  },
  {
    "objectID": "04-visualization-ggplot2.html#customization",
    "href": "04-visualization-ggplot2.html#customization",
    "title": "Data visualization with ggplot2",
    "section": "8 Customization",
    "text": "8 Customization\nTake a look at the ggplot2 cheat sheet, and think of ways you could improve the plot.\nNow, let‚Äôs change names of axes to something more informative than ‚Äòyear‚Äô and ‚Äòn‚Äô and add a title to the figure:\n\nggplot(data = yearly_sex_counts, aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n         x = \"Year of observation\",\n         y = \"Number of individuals\") +\n    theme_bw()\n\n\n\n\nThe axes have more informative names, but their readability can be improved by increasing the font size. This can be done with the generic theme() function:\n\nggplot(data = yearly_sex_counts, mapping = aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n        x = \"Year of observation\",\n        y = \"Number of individuals\") +\n    theme_bw() +\n    theme(text=element_text(size = 16))\n\n\n\n\nNote that it is also possible to change the fonts of your plots. If you are on Windows, you may have to install the extrafont package, and follow the instructions included in the README for this package.\nAfter our manipulations, you may notice that the values on the x-axis are still not properly readable. Let‚Äôs change the orientation of the labels and adjust them vertically and horizontally so they don‚Äôt overlap. You can use a 90 degree angle, or experiment to find the appropriate angle for diagonally oriented labels. We can also modify the facet label text (strip.text) to italicize the genus names:\n\nggplot(data = yearly_sex_counts, mapping = aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n        x = \"Year of observation\",\n        y = \"Number of individuals\") +\n    theme_bw() +\n    theme(axis.text.x = element_text(colour = \"grey20\", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),\n                        axis.text.y = element_text(colour = \"grey20\", size = 12),\n                        strip.text = element_text(face = \"italic\"),\n                        text = element_text(size = 16))\n\n\n\n\nIf you like the changes you created better than the default theme, you can save them as an object to be able to easily apply them to other plots you may create:\n\ngrey_theme <- theme(axis.text.x = element_text(colour=\"grey20\", size = 12,\n                                               angle = 90, hjust = 0.5,\n                                               vjust = 0.5),\n                    axis.text.y = element_text(colour = \"grey20\", size = 12),\n                    text=element_text(size = 16))\n\nggplot(surveys_complete, aes(x = species_id, y = hindfoot_length)) +\n    geom_boxplot() +\n    grey_theme\n\n\n\n\n\n8.1 Challenge\nWith all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio ggplot2 cheat sheet for inspiration.\nHere are some ideas:\n\nSee if you can change the thickness of the lines.\nCan you find a way to change the name of the legend? What about its labels?\nTry using a different color palette (see https://www.cookbook-r.com/Graphs/Colors_(ggplot2)/)."
  },
  {
    "objectID": "04-visualization-ggplot2.html#arranging-plots",
    "href": "04-visualization-ggplot2.html#arranging-plots",
    "title": "Data visualization with ggplot2",
    "section": "9 Arranging plots",
    "text": "9 Arranging plots\nFaceting is a great tool for splitting one plot into multiple plots, but sometimes you may want to produce a single figure that contains multiple plots using different variables or even different data frames. The patchwork package allows us to combine separate ggplots into a single figure while keeping everything aligned properly. Like most R packages, we can install patchwork from CRAN, the R package repository:\n\ninstall.packages(\"patchwork\")\n\nAfter you have loaded the patchwork package you can use + to place plots next to each other, / to arrange them vertically, and plot_layout() to determine how much space each plot uses:\n\nlibrary(patchwork)\n\nplot_weight <- ggplot(data = surveys_complete, aes(x = species_id, y = weight)) +\n  geom_boxplot() +\n  labs(x = \"Species\", y = expression(log[10](Weight))) +\n  scale_y_log10()\n\nplot_count <- ggplot(data = yearly_counts, aes(x = year, y = n, color = genus)) +\n  geom_line() +\n  labs(x = \"Year\", y = \"Abundance\")\n\nplot_weight / plot_count + plot_layout(heights = c(3, 2))\n\n\n\n\nYou can also use parentheses () to create more complex layouts. There are many useful examples on the patchwork website"
  },
  {
    "objectID": "04-visualization-ggplot2.html#exporting-plots",
    "href": "04-visualization-ggplot2.html#exporting-plots",
    "title": "Data visualization with ggplot2",
    "section": "10 Exporting plots",
    "text": "10 Exporting plots\nAfter creating your plot, you can save it to a file in your favorite format. The Export tab in the Plot pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters. The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes.\nInstead, use the ggsave() function, which allows you to easily change the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi):\n\nmy_plot <- ggplot(data = yearly_sex_counts,\n                  aes(x = year, y = n, color = sex)) +\n    geom_line() +\n    facet_wrap(vars(genus)) +\n    labs(title = \"Observed genera through time\",\n        x = \"Year of observation\",\n        y = \"Number of individuals\") +\n    theme_bw() +\n    theme(axis.text.x = element_text(colour = \"grey20\", size = 12, angle = 90,\n                                     hjust = 0.5, vjust = 0.5),\n          axis.text.y = element_text(colour = \"grey20\", size = 12),\n          text = element_text(size = 16))\n\nggsave(\"name_of_file.png\", my_plot, width = 15, height = 10)\n\n## This also works for plots combined with patchwork\nplot_combined <- plot_weight / plot_count + plot_layout(heights = c(3, 2))\nggsave(\"plot_combined.png\", plot_combined, width = 10, dpi = 300)\n\nNote: The parameters width and height also determine the font size in the saved plot.\n\n\n\n\nPage built on: üìÜ 2022-06-28 ‚Äí üï¢ 12:12:13"
  },
  {
    "objectID": "03-dplyr.html#what-are-dplyr-and-tidyr",
    "href": "03-dplyr.html#what-are-dplyr-and-tidyr",
    "title": "Manipulating, analyzing and exporting data with tidyverse",
    "section": "1.1 What are dplyr and tidyr?",
    "text": "1.1 What are dplyr and tidyr?\nThe package dplyr provides helper tools for the most common data manipulation tasks. It is built to work directly with data frames, with many common tasks optimized by being written in a compiled language (C++). An additional feature is the ability to work directly with data stored in an external database. The benefits of doing this are that the data can be managed natively in a relational database, queries can be conducted on that database, and only the results of the query are returned.\nThis addresses a common problem with R in that all operations are conducted in-memory and thus the amount of data you can work with is limited by available memory. The database connections essentially remove that limitation in that you can connect to a database of many hundreds of GB, conduct queries on it directly, and pull back into R only what you need for analysis.\nThe package tidyr addresses the common problem of wanting to reshape your data for plotting and usage by different R functions. For example, sometimes we want data sets where we have one row per measurement. Other times we want a data frame where each measurement type has its own column, and rows are instead more aggregated groups (e.g., a time period, an experimental unit like a plot or a batch number). Moving back and forth between these formats is non-trivial, and tidyr gives you tools for this and more sophisticated data manipulation.\nTo learn more about dplyr and tidyr after the workshop, you may want to check out this handy data transformation with dplyr cheatsheet and this one about tidyr.\nAs before, we‚Äôll read in our data using the read_csv() function from the tidyverse package readr.\n\nsurveys <- read_csv(\"data_raw/portal_data_joined.csv\")\n\n#> Rows: 34786 Columns: 13\n#> ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#> Delimiter: \",\"\n#> chr (6): species_id, sex, genus, species, taxa, plot_type\n#> dbl (7): record_id, month, day, year, plot_id, hindfoot_length, weight\n#> \n#> ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#> ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n## inspect the data\nstr(surveys)\n\n\n## preview the data\nview(surveys)\n\nNext, we‚Äôre going to learn some of the most common dplyr functions:\n\nselect(): subset columns\nfilter(): subset rows on conditions\nmutate(): create new columns by using information from other columns\ngroup_by() and summarize(): create summary statistics on grouped data\narrange(): sort results\ncount(): count discrete values"
  },
  {
    "objectID": "03-dplyr.html#selecting-columns-and-filtering-rows",
    "href": "03-dplyr.html#selecting-columns-and-filtering-rows",
    "title": "Manipulating, analyzing and exporting data with tidyverse",
    "section": "1.2 Selecting columns and filtering rows",
    "text": "1.2 Selecting columns and filtering rows\nTo select columns of a data frame, use select(). The first argument to this function is the data frame (surveys), and the subsequent arguments are the columns to keep.\n\nselect(surveys, plot_id, species_id, weight)\n\nTo select all columns except certain ones, put a ‚Äú-‚Äù in front of the variable to exclude it.\n\nselect(surveys, -record_id, -species_id)\n\nThis will select all the variables in surveys except record_id and species_id.\nTo choose rows based on a specific criterion, use filter():\n\nfilter(surveys, year == 1995)"
  },
  {
    "objectID": "03-dplyr.html#pipes",
    "href": "03-dplyr.html#pipes",
    "title": "Manipulating, analyzing and exporting data with tidyverse",
    "section": "1.3 Pipes",
    "text": "1.3 Pipes\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nsurveys2 <- filter(surveys, weight < 5)\nsurveys_sml <- select(surveys2, species_id, sex, weight)\n\nThis is readable, but can clutter up your workspace with lots of objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e.¬†one function inside of another), like this:\n\nsurveys_sml <- select(filter(surveys, weight < 5), species_id, sex, weight)\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipes in R look like %>% and are made available via the magrittr package, installed automatically with dplyr. If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac.\n\nsurveys %>%\n  filter(weight < 5) %>%\n  select(species_id, sex, weight)\n\nIn the above code, we use the pipe to send the surveys dataset first through filter() to keep rows where weight is less than 5, then through select() to keep only the species_id, sex, and weight columns. Since %>% takes the object on its left and passes it as the first argument to the function on its right, we don‚Äôt need to explicitly include the data frame as an argument to the filter() and select() functions any more.\nSome may find it helpful to read the pipe like the word ‚Äúthen.‚Äù For instance, in the example above, we took the data frame surveys, then we filtered for rows with weight < 5, then we selected columns species_id, sex, and weight. The dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe we can accomplish more complex manipulations of data frames.\nIf we want to create a new object with this smaller version of the data, we can assign it a new name:\n\nsurveys_sml <- surveys %>%\n  filter(weight < 5) %>%\n  select(species_id, sex, weight)\n\nsurveys_sml\n\nNote that the final data frame is the leftmost part of this expression.\n\n1.3.1 Challenge\nUsing pipes, subset the surveys data to include animals collected before 1995 and retain only the columns year, sex, and weight.\n\n\n\nAnswer\n\n\nsurveys %>%\n    filter(year < 1995) %>%\n    select(year, sex, weight)\n\n\n\n\n\n\n\n\n1.3.2 Mutate\nFrequently you‚Äôll want to create new columns based on the values in existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we‚Äôll use mutate().\nTo create a new column of weight in kg:\n\nsurveys %>%\n  mutate(weight_kg = weight / 1000)\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nsurveys %>%\n  mutate(weight_kg = weight / 1000,\n         weight_lb = weight_kg * 2.2)\n\nIf this runs off your screen and you just want to see the first few rows, you can use a pipe to view the head() of the data. (Pipes work with non-dplyr functions, too, as long as the dplyr or magrittr package is loaded).\n\nsurveys %>%\n  mutate(weight_kg = weight / 1000) %>%\n  head()\n\nThe first few rows of the output are full of NAs, so if we wanted to remove those we could insert a filter() in the chain:\n\nsurveys %>%\n  filter(!is.na(weight)) %>%\n  mutate(weight_kg = weight / 1000) %>%\n  head()\n\nis.na() is a function that determines whether something is an NA. The ! symbol negates the result, so we‚Äôre asking for every row where weight is not an NA.\n\n1.3.3 Challenge\nCreate a new data frame from the surveys data that meets the following criteria: contains only the species_id column and a new column called hindfoot_cm containing the hindfoot_length values (currently in mm) converted to centimeters. In this hindfoot_cm column, there are no NAs and all values are less than 3.\nHint: think about how the commands should be ordered to produce this data frame!\n\n\n\nAnswer\n\n\nsurveys_hindfoot_cm <- surveys %>%\n    filter(!is.na(hindfoot_length)) %>%\n    mutate(hindfoot_cm = hindfoot_length / 10) %>%\n    filter(hindfoot_cm < 3) %>%\n    select(species_id, hindfoot_cm)\n\n\n\n\n\n\n\n\n\n1.3.4 Split-apply-combine data analysis and the summarize() function\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. Key functions of dplyr for this workflow are group_by() and summarize().\n\n1.3.4.1 The group_by() and summarize() functions\ngroup_by() is often used together with summarize(), which collapses each group into a single-row summary of that group. group_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. So to compute the mean weight by sex:\n\nsurveys %>%\n  group_by(sex) %>%\n  summarize(mean_weight = mean(weight, na.rm = TRUE))\n\nYou may also have noticed that the output from these calls doesn‚Äôt run off the screen anymore. It‚Äôs one of the advantages of tbl_df over data frame.\nYou can also group by multiple columns:\n\nsurveys %>%\n  group_by(sex, species_id) %>%\n  summarize(mean_weight = mean(weight, na.rm = TRUE)) %>%\n  tail()\n\n#> `summarise()` has grouped output by 'sex'. You can override using the `.groups`\n#> argument.\n\n\nHere, we used tail() to look at the last six rows of our summary. Before, we had used head() to look at the first six rows. We can see that the sex column contains NA values because some animals had escaped before their sex and body weights could be determined. The resulting mean_weight column does not contain NA but NaN (which refers to ‚ÄúNot a Number‚Äù) because mean() was called on a vector of NA values while at the same time setting na.rm = TRUE. To avoid this, we can remove the missing values for weight before we attempt to calculate the summary statistics on weight. Because the missing values are removed first, we can omit na.rm = TRUE when computing the mean:\n\nsurveys %>%\n  filter(!is.na(weight)) %>%\n  group_by(sex, species_id) %>%\n  summarize(mean_weight = mean(weight))\n\n#> `summarise()` has grouped output by 'sex'. You can override using the `.groups`\n#> argument.\n\n\nHere, again, the output from these calls doesn‚Äôt run off the screen anymore. If you want to display more data, you can use the print() function at the end of your chain with the argument n specifying the number of rows to display:\n\nsurveys %>%\n  filter(!is.na(weight)) %>%\n  group_by(sex, species_id) %>%\n  summarize(mean_weight = mean(weight)) %>%\n  print(n = 15)\n\n#> `summarise()` has grouped output by 'sex'. You can override using the `.groups`\n#> argument.\n\n\nOnce the data are grouped, you can also summarize multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the minimum weight for each species for each sex:\n\nsurveys %>%\n  filter(!is.na(weight)) %>%\n  group_by(sex, species_id) %>%\n  summarize(mean_weight = mean(weight),\n            min_weight = min(weight))\n\n#> `summarise()` has grouped output by 'sex'. You can override using the `.groups`\n#> argument.\n\n\nIt is sometimes useful to rearrange the result of a query to inspect the values. For instance, we can sort on min_weight to put the lighter species first:\n\nsurveys %>%\n  filter(!is.na(weight)) %>%\n  group_by(sex, species_id) %>%\n  summarize(mean_weight = mean(weight),\n            min_weight = min(weight)) %>%\n  arrange(min_weight)\n\n#> `summarise()` has grouped output by 'sex'. You can override using the `.groups`\n#> argument.\n\n\nTo sort in descending order, we need to add the desc() function. If we want to sort the results by decreasing order of mean weight:\n\nsurveys %>%\n  filter(!is.na(weight)) %>%\n  group_by(sex, species_id) %>%\n  summarize(mean_weight = mean(weight),\n            min_weight = min(weight)) %>%\n  arrange(desc(mean_weight))\n\n#> `summarise()` has grouped output by 'sex'. You can override using the `.groups`\n#> argument.\n\n\n\n\n1.3.4.2 Counting\nWhen working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each sex, we would do:\n\nsurveys %>%\n    count(sex)\n\nThe count() function is shorthand for something we‚Äôve already seen: grouping by a variable, and summarizing it by counting the number of observations in that group. In other words, surveys %>% count() is equivalent to:\n\nsurveys %>%\n    group_by(sex) %>%\n    summarise(count = n())\n\nFor convenience, count() provides the sort argument:\n\nsurveys %>%\n    count(sex, sort = TRUE)\n\nPrevious example shows the use of count() to count the number of rows/observations for one factor (i.e., sex). If we wanted to count combination of factors, such as sex and species, we would specify the first and the second factor as the arguments of count():\n\nsurveys %>%\n  count(sex, species)\n\nWith the above code, we can proceed with arrange() to sort the table according to a number of criteria so that we have a better comparison. For instance, we might want to arrange the table above in (i) an alphabetical order of the levels of the species and (ii) in descending order of the count:\n\nsurveys %>%\n  count(sex, species) %>%\n  arrange(species, desc(n))\n\nFrom the table above, we may learn that, for instance, there are 75 observations of the albigula species that are not specified for its sex (i.e.¬†NA).\n\n1.3.5 Challenge\n\nHow many animals were caught in each plot_type surveyed?\n\n\n\n\nAnswer\n\n\nsurveys %>%\n    count(plot_type)\n\n\n\n\nUse group_by() and summarize() to find the mean, min, and max hindfoot length for each species (using species_id). Also add the number of observations (hint: see ?n).\n\n\n\n\nAnswer\n\n\nsurveys %>%\n    filter(!is.na(hindfoot_length)) %>%\n    group_by(species_id) %>%\n    summarize(\n        mean_hindfoot_length = mean(hindfoot_length),\n        min_hindfoot_length = min(hindfoot_length),\n        max_hindfoot_length = max(hindfoot_length),\n        n = n()\n    )\n\n\n\n\nWhat was the heaviest animal measured in each year? Return the columns year, genus, species_id, and weight.\n\n\n\n\nAnswer\n\n\nsurveys %>%\n    filter(!is.na(weight)) %>%\n    group_by(year) %>%\n    filter(weight == max(weight)) %>%\n    select(year, genus, species, weight) %>%\n    arrange(year)\n\n\n\n\n\n\n\n\n\n\n1.3.6 Reshaping with gather and spread\nIn the spreadsheet lesson, we discussed how to structure our data leading to the four rules defining a tidy dataset:\n\nEach variable has its own column\nEach observation has its own row\nEach value must have its own cell\nEach type of observational unit forms a table\n\nHere we examine the fourth rule: Each type of observational unit forms a table.\nIn surveys, the rows of surveys contain the values of variables associated with each record (the unit), values such as the weight or sex of each animal associated with each record. What if instead of comparing records, we wanted to compare the different mean weight of each genus between plots? (Ignoring plot_type for simplicity).\nWe‚Äôd need to create a new table where each row (the unit) is comprised of values of variables associated with each plot. In practical terms this means the values in genus would become the names of column variables and the cells would contain the values of the mean weight observed on each plot.\nHaving created a new table, it is therefore straightforward to explore the relationship between the weight of different genera within, and between, the plots. The key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest: average genus weight per plot instead of recordings per date.\nThe opposite transformation would be to transform column names into values of a variable.\nWe can do both these of transformations with two tidyr functions, spread() and gather().\n\n1.3.6.1 Spreading\nspread() takes three principal arguments:\n\nthe data\nthe key column variable whose values will become new column names.\n\nthe value column variable whose values will fill the new column variables.\n\nFurther arguments include fill which, if set, fills in missing values with the value provided.\nLet‚Äôs use spread() to transform surveys to find the mean weight of each genus in each plot over the entire survey period. We use filter(), group_by() and summarise() to filter our observations and variables of interest, and create a new variable for the mean_weight.\n\nsurveys_gw <- surveys %>%\n  filter(!is.na(weight)) %>%\n  group_by(plot_id, genus) %>%\n  summarize(mean_weight = mean(weight))\n\n#> `summarise()` has grouped output by 'plot_id'. You can override using the\n#> `.groups` argument.\n\nstr(surveys_gw)\n\nThis yields surveys_gw where the observations for each plot are spread across multiple rows, 196 observations of 3 variables. Using spread() to key on genus with values from mean_weight this becomes 24 observations of 11 variables, one row for each plot.\n\nsurveys_spread <- surveys_gw %>%\n  spread(key = genus, value = mean_weight)\n\nstr(surveys_spread)\n\n\nWe could now plot comparisons between the weight of genera (one is called a genus, multiple are called genera) in different plots, although we may wish to fill in the missing values first.\n\nsurveys_gw %>%\n  spread(genus, mean_weight, fill = 0) %>%\n  head()\n\n\n\n1.3.6.2 Gathering\nThe opposing situation could occur if we had been provided with data in the form of surveys_spread, where the genus names are column names, but we wish to treat them as values of a genus variable instead.\nIn this situation we are gathering the column names and turning them into a pair of new variables. One variable represents the column names as values, and the other variable contains the values previously associated with the column names.\ngather() takes four principal arguments:\n\nthe data\nthe key column variable we wish to create from column names.\nthe values column variable we wish to create and fill with values associated with the key.\nthe names of the columns we use to fill the key variable (or to drop).\n\nTo recreate surveys_gw from surveys_spread we would create a key called genus and value called mean_weight and use all columns except plot_id for the key variable. Here we exclude plot_id from being gather()ed.\n\nsurveys_gather <- surveys_spread %>%\n  gather(key = \"genus\", value = \"mean_weight\", -plot_id)\n\nstr(surveys_gather)\n\n\nNote that now the NA genera are included in the re-gathered format. Spreading and then gathering can be a useful way to balance out a dataset so every replicate has the same composition.\nWe could also have used a specification for what columns to include. This can be useful if you have a large number of identifying columns, and it allows you to type less in order to specify what to gather than what to leave alone. And if the columns are directly adjacent, we don‚Äôt even need to list them all out - instead you can use the : operator!\n\nsurveys_spread %>%\n  gather(key = \"genus\", value = \"mean_weight\", Baiomys:Spermophilus) %>%\n  head()\n\n\n1.3.7 Challenge\n\nSpread the surveys data frame with year as columns, plot_id as rows, and the number of genera per plot as the values. You will need to summarize before reshaping, and use the function n_distinct() to get the number of unique genera within a particular chunk of data. It‚Äôs a powerful function! See ?n_distinct for more.\n\n\n\n\nAnswer\n\n\nsurveys_spread_genera <- surveys %>%\n  group_by(plot_id, year) %>%\n  summarize(n_genera = n_distinct(genus)) %>%\n  spread(year, n_genera)\n\n#> `summarise()` has grouped output by 'plot_id'. You can override using the\n#> `.groups` argument.\n\nhead(surveys_spread_genera)\n\n\n\n\nNow take that data frame and gather() it again, so each row is a unique plot_id by year combination.\n\n\n\n\nAnswer\n\n\nsurveys_spread_genera %>%\n  gather(\"year\", \"n_genera\", -plot_id)\n\n\n\n\nThe surveys data set has two measurement columns: hindfoot_length and weight. This makes it difficult to do things like look at the relationship between mean values of each measurement per year in different plot types. Let‚Äôs walk through a common solution for this type of problem. First, use gather() to create a dataset where we have a key column called measurement and a value column that takes on the value of either hindfoot_length or weight. Hint: You‚Äôll need to specify which columns are being gathered.\n\n\n\n\nAnswer\n\n\nsurveys_long <- surveys %>%\n  gather(\"measurement\", \"value\", hindfoot_length, weight)\n\n\n\n\nWith this new data set, calculate the average of each measurement in each year for each different plot_type. Then spread() them into a data set with a column for hindfoot_length and weight. Hint: You only need to specify the key and value columns for spread().\n\n\n\n\nAnswer\n\n\nsurveys_long %>%\n  group_by(year, measurement, plot_type) %>%\n  summarize(mean_value = mean(value, na.rm=TRUE)) %>%\n  spread(measurement, mean_value)\n\n#> `summarise()` has grouped output by 'year', 'measurement'. You can override\n#> using the `.groups` argument."
  },
  {
    "objectID": "instructor-notes.html",
    "href": "instructor-notes.html",
    "title": "Instructor notes",
    "section": "",
    "text": "The data used for this lesson are in the figshare repository at: https://doi.org/10.6084/m9.figshare.1314459\nThis lesson uses mostly combined.csv. The 3 other csv files: plots.csv, species.csv and surveys.csv are only needed for the lesson on databases.\ncombined.csv is downloaded directly in the episode ‚ÄúStarting with Data‚Äù and does not need to be downloaded before hand. It however requires that there is a decent internet connection in the room where the workshop is being taught. To facilitate the download process, the chunk of code that includes the URL where the csv file lives, and where the file should go and be named is included in the code handout (see next paragraph). Using this approach ensures that the file will be where the lesson expects it to be, and teaches good/reproducible practice of automating the download. If the learners haven‚Äôt created the data/ directory and/or are not in the correct working directory, the download.file command will produce an error. Therefore, it is important to use the stickies at this point."
  },
  {
    "objectID": "instructor-notes.html#the-handout",
    "href": "instructor-notes.html#the-handout",
    "title": "Instructor notes",
    "section": "2 The handout",
    "text": "2 The handout\nThe code handout (a link to download it is also available on the top bar of the lesson website) is useful for Data Carpentry workshops. It includes an outline of the lesson content, the text for the challenges, the links for the files that need to be downloaded for the lesson, and pieces of code that may be difficult to type for learners with no programming experience/who are unfamiliar with R‚Äôs syntax. We encourage you to distribute it to the learners at the beginning of the lesson. As an instructor, we encourage you to do the live coding directly in this file, so the participants can follow along."
  },
  {
    "objectID": "instructor-notes.html#r-version",
    "href": "instructor-notes.html#r-version",
    "title": "Instructor notes",
    "section": "3 R Version",
    "text": "3 R Version\nWith the release of R 4.0.0 in early 2020, an important change has been made to R: The default for stringsAsFactors is now FALSE instead of TRUE. As a result, the read.csv() and data.frame() functions do not automatically convert character columns to factors anymore (you can read more about it in this post on the R developer blog).\nThis change should not cause any problems with this lesson, independent of whether R >4.0 is used or not, because it uses read_csv() from the tidyverse package throughout. Other than read.csv() from base R, read_csv() never converts character columns to factors, regardless of the R version.\nNevertheless, it is recommended that learners install a version of R ‚â•4.0.0, and instructors and helpers should be aware of this potential source of error."
  },
  {
    "objectID": "instructor-notes.html#rstudio-and-multiple-r-installs",
    "href": "instructor-notes.html#rstudio-and-multiple-r-installs",
    "title": "Instructor notes",
    "section": "4 RStudio and Multiple R Installs",
    "text": "4 RStudio and Multiple R Installs\nSome learners may have previous R installations. On Mac, if a new install is performed, the learner‚Äôs system will create a symbolic link, pointing to the new install as ‚ÄòCurrent.‚Äô Sometimes this process does not occur, and, even though a new R is installed and can be accessed via the R console, RStudio does not find it. The net result of this is that the learner‚Äôs RStudio will be running an older R install. This will cause package installations to fail. This can be fixed at the terminal. First, check for the appropriate R installation in the library;\nls -l /Library/Frameworks/R.framework/Versions/\nWe are currently using R 4.0.x. If it isn‚Äôt there, they will need to install it. If it is present, you will need to set the symbolic link to Current to point to the 4.0.x directory:\nln -s /Library/Frameworks/R.framework/Versions/3.6.x /Library/Frameworks/R.framework/Version/Current\nThen restart RStudio."
  },
  {
    "objectID": "instructor-notes.html#issues-with-fonts-on-macos",
    "href": "instructor-notes.html#issues-with-fonts-on-macos",
    "title": "Instructor notes",
    "section": "5 Issues with Fonts on MacOS",
    "text": "5 Issues with Fonts on MacOS\nOn older versions of MacOS, it may happen that axis labels do not show up when calling plot() (section ‚Äúrenaming factors‚Äù in ‚ÄúStarting with Data‚Äù). This issue might be due to the default font Arial being deactivated, so that R cannot find it. To resolve this issue, go to Finder, Search for Font Book and open it. Look for the Arial font and, if it is greyed out, turn it on.\nIf the problem occurs with ggplot2 plots, an alternative workaround is to change the default theme for the R session, so that ggplot uses a serif font. Since Arial is a sans-serif font, R will try to load a different font. This can be done with theme_update(text = element_text(family = \"serif\"))."
  },
  {
    "objectID": "instructor-notes.html#required-packages",
    "href": "instructor-notes.html#required-packages",
    "title": "Instructor notes",
    "section": "6 Required packages",
    "text": "6 Required packages\nSave yourself some aggrevation, and have everyone check and see if they can install all these packages before you start the first day. See the ‚ÄúPreparations‚Äù section on the homepage of the course website for package installation instructions.\nSometimes learners are unable to install the tidyverse package. In that case, they can try to install the individual packages that are actually needed:\ninstall.packages(c(\"readr\", \"lubridate\", \"dplyr\", \"tidyr\", \"ggplot2\", \"dbplyr\"))"
  },
  {
    "objectID": "instructor-notes.html#narrative",
    "href": "instructor-notes.html#narrative",
    "title": "Instructor notes",
    "section": "7 Narrative",
    "text": "7 Narrative\n\n7.1 Before we start\n\nThe main goal here is to help the learners be comfortable with the RStudio interface. We use RStudio because it helps make using R more organized and user friendly.\nThe ‚ÄúWhy learning R?‚Äù section contains suggestions of what you could tell your learners about the benefits of learning R. However, it‚Äôs best if you can talk here about what has worked for you personally.\nGo very slowly in the ‚ÄúGetting setup section‚Äù. Make sure everyone is following along (remind learners to use the stickies). Plan with the helpers at this point to go around the room, and be available to help. It‚Äôs important to make sure that learners are in the correct working directory, and that they create a data_raw (all lowercase) subfolder.\nThe seeking help section is relatively long, and while it‚Äôs useful to demonstrate a couple of ways to get help from within R, you may want to mostly point the workshop participants to this useful reference so that they can refer to it after the workshop.\nIn the ‚Äúwhere to ask for help section?‚Äù, you may want to emphasize the first point about how workshops are a great way to create community of learners that can help each others during and after the workshop.\n\n\n\n7.2 Intro to R\n\nWhen going over the section on assignments, make sure to pause for at least 30 seconds when asking ‚ÄúWhat do you think is the current content of the object weight_lb? 126.5 or 220?‚Äù. For learners with no programming experience, this is a new and important concept.\nGiven that the concept of missing data is an important feature of the R language, it is worth spending enough time on it.\n\n\n\n7.3 Starting with data\nThe two main goals for this lessons are:\n\nTo make sure that learners are comfortable with working with data frames, and can use the bracket notation to select slices/columns\nTo expose learners to factors. Their behavior is not necessarily intuitive, and so it is important that they are guided through it the first time they are exposed to it. The content of the lesson should be enough for learners to avoid common mistakes with them.\nIf the learners are not familiar with the ecology terminology used in the data set, it might be a good idea to briefly review it here. Especially the terms genus and plot have caused some confusion to learners in the past. It might help to point out that the plural of genus is genera, and that plot_id and plot_type in the data set refer to the ID and type of a plot of land that was surveyed by the researchers in the study.\n\n\n\n7.4 Manipulating data\n\nFor this lesson make sure that learners are comfortable using pipes.\nThere is also sometimes some confusion on what the arguments of group_by should be.\nThis lesson uses the tidyr package to reshape data for plotting\nAfter this lesson students should be familiar with the spread() and gather() functions available in tidyr\nWhile working with the example for mutate(), it is difficult to see the ‚Äúweight‚Äù columns on a zoomed in RStudio screen. Including a select() command to select the columns ‚Äúweight_kg‚Äù and ‚Äúweight_lb‚Äù makes it easier to view how the ‚Äúweight‚Äù columns are changed.\nIt is crucial that learners use the function read_csv() from tidyverse, not read.csv() from base R. Using the wrong function will cause unexpected results further down the line, especially in the section on working with factors.\nNote: If students end up with 30521 rows for surveys_complete instead of the expected 30463 rows at the end of the chapter, then they have likely used read.csv() and not read_csv() to import the data.\nWhen explaining view(), consider mentioning that is a function of the tibble package, and that the base function View() can also be used to view a data frame.\n\n\n\n7.5 Visualizing data\n\nThis lesson is a broad overview of ggplot2 and focuses on (1) getting familiar with the layering system of ggplot2, (2) using the argument group in the aes() function, (3) basic customization of the plots.\nIt maybe worthwhile to mention that we can also specify colors by color HEX code (http://colorbrewer2.org) ggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length)) +         geom_point(alpha = 0.1, color = \"#FF0000\")\n\n\n\n7.6 R and SQL\n\nIdeally this lesson is best taught at the end of the workshop (as a capstone example) to illustrate how the tools covered can integrate with each others. Depending on the audience, and the pace of the workshop, it can be shown as a demonstration rather than a typically lesson.\nThe explanation of how dplyr‚Äôs verb syntax is translated into SQL statements, and the section on laziness are optional and don‚Äôt need to be taught in detail during a workshop. They can be useful after a workshop for learners interested in learning more about the topics or for instructors to answer questions from the workshop participants."
  },
  {
    "objectID": "instructor-notes.html#potential-issues-solutions",
    "href": "instructor-notes.html#potential-issues-solutions",
    "title": "Instructor notes",
    "section": "8 Potential issues & solutions",
    "text": "8 Potential issues & solutions\nAs it stands, the solutions to all the challenges are commented out in the Rmd files. If you want to double check your answer, you can look at the source code of the Rmd files on GitHub."
  },
  {
    "objectID": "instructor-notes.html#technical-tips-and-tricks",
    "href": "instructor-notes.html#technical-tips-and-tricks",
    "title": "Instructor notes",
    "section": "9 Technical Tips and Tricks",
    "text": "9 Technical Tips and Tricks\nShow how to use the ‚Äòzoom‚Äô button to blow up graphs without constantly resizing windows\nSometimes a package will not install, try a different CRAN mirror - Tools > Global Options > Packages > CRAN Mirror\nAlternatively you can go to CRAN and download the package and install from ZIP file - Tools > Install Packages > set to ‚Äòfrom Zip/TAR‚Äô\nIt is important that R, and the R packages be installed locally, not on a network drive. If a learner is using a machine with multiple users where their account is not based locally this can create a variety of issues (This often happens on university computers). Hopefully the learner will realize these issues before hand, but depending on the machine and how the IT folks that service the computer have things set up, it may be very difficult to impossible to make R work without their help.\nIf learners are having issues with one package, they may have issues with another. It is often easier to make sure they have all the necessary packages installed at one time, rather then deal with these issues over and over.\nIn lesson 2 starting with data, one might not have the appropriate folder ‚Äúdata_raw‚Äù in their working directory causing an error. This is a good time to go over reading an error, and a brief introduction of how to identify your working directory getwd() as well as setting your working directory setwd(\"/somedirectory\") and if needed creating a directory within your script dir.create(\"/some_new_directory\"), or simply creating it within a file explorer works if short on time."
  },
  {
    "objectID": "instructor-notes.html#other-resources",
    "href": "instructor-notes.html#other-resources",
    "title": "Instructor notes",
    "section": "10 Other Resources",
    "text": "10 Other Resources\nIf you encounter a problem during a workshop, feel free to contact the maintainers by email or open an issue.\nFor a more in-depth coverage of topics of the workshops, you may want to read ‚ÄúR for Data Science‚Äù by Hadley Wickham and Garrett Grolemund."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Analysis and Visualization in R for Ecologists",
    "section": "",
    "text": "Data Carpentry‚Äôs aim is to teach researchers basic concepts, skills, and tools for working with data so that they can get more done in less time, and with less pain. The lessons below were designed for those interested in working with ecology data in R.\nThis is an introduction to R designed for participants with no programming experience. These lessons can be taught in a day (~ 6 hours). They start with some basic information about R syntax, the RStudio interface, and move through how to import CSV files, the structure of data frames, how to deal with factors, how to add/remove rows and columns, how to calculate summary statistics from a data frame, and a brief introduction to plotting. The last lesson demonstrates how to work with databases directly from R.\nThis lesson assumes no prior knowledge of R or RStudio and no programming experience."
  },
  {
    "objectID": "index.html#episodes",
    "href": "index.html#episodes",
    "title": "Data Analysis and Visualization in R for Ecologists",
    "section": "\n1 Episodes",
    "text": "1 Episodes\n\nBefore we start\nIntroduction to R\nStarting with data\nManipulating, analyzing and exporting data with tidyverse\nData visualization with ggplot2\nSQL databases and R"
  },
  {
    "objectID": "index.html#preparations",
    "href": "index.html#preparations",
    "title": "Data Analysis and Visualization in R for Ecologists",
    "section": "\n2 Preparations",
    "text": "2 Preparations\nData Carpentry‚Äôs teaching is hands-on, and to follow this lesson learners must have R and RStudio installed on their computers. They also need to be able to install a number of R packages, create directories, and download files.\nTo avoid troubleshooting during the lesson, learners should follow the instruction below to download and install everything beforehand. If they are using their own computers this should be no problem, but if the computer is managed by their organization‚Äôs IT department they might need help from an IT administrator.\n\n2.1 Install R and RStudio\nR and RStudio are two separate pieces of software:\n\n\nR is a programming language that is especially powerful for data exploration, visualization, and statistical analysis\n\nRStudio is an integrated development environment (IDE) that makes using R easier. In this course we use RStudio to interact with R.\n\nIf you don‚Äôt already have R and RStudio installed, follow the instructions for your operating system below. You have to install R before you install RStudio.\n\n2.1.1 Windows\n\nDownload R from the CRAN website.\nRun the .exe file that was just downloaded\nGo to the RStudio download page\n\nUnder Installers select RStudio x.yy.zzz - Windows Vista/7/8/10 (where x, y, and z represent version numbers)\nDouble click the file to install it\nOnce it‚Äôs installed, open RStudio to make sure it works and you don‚Äôt get any error messages.\n\n\n2.1.1.1 MacOS\n\nDownload R from the CRAN website.\nSelect the .pkg file for the latest R version\nDouble click on the downloaded file to install R\nIt is also a good idea to install XQuartz (needed by some packages)\nGo to the RStudio download page\n\nUnder Installers select RStudio x.yy.zzz - Mac OS X 10.6+ (64-bit) (where x, y, and z represent version numbers)\nDouble click the file to install RStudio\nOnce it‚Äôs installed, open RStudio to make sure it works and you don‚Äôt get any error messages.\n\n2.1.1.2 Linux\n\nFollow the instructions for your distribution from CRAN, they provide information to get the most recent version of R for common distributions. For most distributions, you could use your package manager (e.g., for Debian/Ubuntu run sudo apt-get install r-base, and for Fedora sudo yum install R), but we don‚Äôt recommend this approach as the versions provided by this are usually out of date. In any case, make sure you have at least R 3.3.1.\nGo to the RStudio download page\n\nUnder Installers select the version that matches your distribution, and install it with your preferred method (e.g., with Debian/Ubuntu sudo dpkg -i   rstudio-x.yy.zzz-amd64.deb at the terminal).\nOnce it‚Äôs installed, open RStudio to make sure it works and you don‚Äôt get any error messages.\n\n2.2 Update R and RStudio\nIf you already have R and RStudio installed, first check if your R version is up to date:\n\nWhen you open RStudio your R version will be printed in the console on the bottom left. Alternatively, you can type sessionInfo() into the console. If your R version is 4.0.0 or later, you don‚Äôt need to update R for this lesson. If your version of R is older than that, download and install the latest version of R from the R project website for Windows, for MacOS, or for Linux\n\nIt is not necessary to remove old versions of R from your system, but if you wish to do so you can check How do I uninstall R?\n\nNote: The changes introduced by new R versions are usually backwards-compatible. That is, your old code should still work after updating your R version. However, if breaking changes happen, it is useful to know that you can have multiple versions of R installed in parallel and that you can switch between them in RStudio by going to Tools > Global Options > General > Basic.\nAfter installing a new version of R, you will have to reinstall all your packages with the new version. For Windows, there is a package called installr that can help you with upgrading your R version and migrate your package library.\n\nTo update RStudio to the latest version, open RStudio and click on Help > Check for Updates. If a new version is available follow the instruction on screen. By default, RStudio will also automatically notify you of new versions every once in a while.\n\n2.3 Install required R packages\nDuring the course we will need a number of R packages. Packages contain useful R code written by other people. We will use the packages tidyverse, hexbin, patchwork, and RSQLite.\nTo try to install these packages, open RStudio and copy and paste the following command into the console window (look for a blinking cursor on the bottom left), then press the Enter (Windows and Linux) or Return (MacOS) to execute the command.\n\ninstall.packages(c(\"tidyverse\", \"hexbin\", \"patchwork\", \"RSQLite\"))\n\nAlternatively, you can install the packages using RStudio‚Äôs graphical user interface by going to Tools > Install Packages and typing the names of the packages separated by a comma.\nR tries to download and install the packages on your machine. When the installation has finished, you can try to load the packages by pasting the following code into the console:\n\nlibrary(tidyverse)\nlibrary(hexbin)\nlibrary(patchwork)\nlibrary(RSQLite)\n\nIf you do not see an error like there is no package called ‚Äò...‚Äô you are good to go!\n\n2.4 Updating R packages\nGenerally, it is recommended to keep your R version and all packages up to date, because new versions bring improvements and important bugfixes. To update the packages that you have installed, click Update in the Packages tab in the bottom right panel of RStudio, or go to Tools > Check for Package Updates....\nSometimes, package updates introduce changes that break your old code, which can be very frustrating. To avoid this problem, you can use a package called renv. It locks the package versions you have used for a given project and makes it straightforward to reinstall those exact package version in a new environment, for example after updating your R version or on another computer. However, the details are outside of the scope of this lesson.\n\n2.5 Download the data\nWe will download the data directly from R during the lessons. However, if you are expecting problems with the network, it may be better to download the data beforehand and store it on your machine.\nThe data files for the lesson can be downloaded manually here: https://doi.org/10.6084/m9.figshare.1314459"
  },
  {
    "objectID": "index.html#contributors",
    "href": "index.html#contributors",
    "title": "Data Analysis and Visualization in R for Ecologists",
    "section": "\n3 Contributors",
    "text": "3 Contributors\nThe list of contributors to this lesson is available here.\n\nPage built on: üìÜ 2022-06-28 ‚Äí üï¢ 12:11:17"
  }
]